\chapter{Getting Started}

\section{Introduction}

This chapter provides a brief introduction to creating EPICS IOC applications. It contains:

\begin{itemize}\item Instructions for creating, building, and running an example IOC application.

\item Instructions for creating, building, and executing example Channel Access clients.

\item Briefly describes iocsh, which is a base supplied command shell.

\item Describes rules for building IOC components.

\item Describes makeBaseApp.pl, which is a perl script that generates files for building applications.

\item Briefly discusses vxWorks boot parameters

\end{itemize}This chapter will be hard to understand unless you have some familarity with IOC concepts such as record/device/driver 
support and have had some experience with creating ioc databases. Once you have this experience, this chapter provides 
most of the information needed to build applications. The example that follows assumes that EPICS base has already been 
built.

\section{Example IOC Application}

\index{74367: HEADING1: 2.2 Example IOC Application}This section explains how to create an example IOC application in a directory \textless{}top\textgreater{}, naming the application 
\verb|myexampleApp| and the ioc directory \verb|iocmyexample|.

\subsection{Check that \texttt{EPICS\_HOST\_ARCH} is defined}

Execute the command:

\begin{verbatim}echo $EPICS_HOST_ARCH         (Unix/Linux)
\end{verbatim}or

\begin{verbatim}set EPICS_HOST_ARCH             (Windows)
\end{verbatim}This should display your workstation architecture, for example \verb|linux-x86| or \verb|win32-x86|. If you get an ``Undefined 
variable" error, you should set EPICS\_HOST\_ARCH to your host operating system followed by a dash and then your host 
architecture, e.g.  solaris-sparc. The perl script EpicsHostArch.pl in the base/startup directory has been provided to help 
set EPICS\_HOST\_ARCH.

\subsection{Create the example application}

The following commands create an example application.

\begin{verbatim}mkdir <top>
cd <top>
<base>/bin/<arch>/makeBaseApp.pl -t example myexample
<base>/bin/<arch>/makeBaseApp.pl -i -t example myexample
\end{verbatim}Here, \textless{}arch\textgreater{} indicates the operating system architecture of your computer.  For example, solaris-sparc. The last command 
will ask you to enter an architecture for the IOC. It provides a list of architectures for which base has been built.

The full path name to \textless{}base\textgreater{} (an already built copy of EPICS base) must be given. Check with your EPICS system 
administrator to see what the path to your \textless{}base\textgreater{} is. For example:

\begin{verbatim}/home/phoebus/MRK/epics/base/bin/linux-x86/makeBaseApp.pl ...
\end{verbatim}Windows Users Note: Perl scripts are invoked with the command perl \textless{}scriptname\textgreater{} on win95/NT. Perl script names are 
case sensitive. For example to create an application on WIN95/NT:

\begin{verbatim}perl C:\epics\base\bin\win32-x86\makeBaseApp.pl -t example myexample
\end{verbatim}\subsection{Inspect files}

Spend some time looking at the files that appear under \textless{}top\textgreater{}. Do this BEFORE building. This allows you to see typical 
files which are needed to build an application without seeing the files generated by make.

\subsection{Sequencer Example}

The sequencer is now supported as an unbundled product. The example includes an example state notation program; 
sncExample.stt. As created by makeBaseApp the example is not built or executed.

Before sncExample.st can be built, the sequencer must be built using the same version of base that the example uses.

To build sncExample edit the following files:

\begin{itemize}
\item configure/RELEASE - Set SNCSEQ to the location of the sequencer.
\item iocBoot/iocmyexample/st.cmd - Remove the comment character \# from 

\#seq sncExample,"user=\textless{}user"
\end{itemize}

The Makefile contains commands for building sncExample as a component of the ioc application and as a standalone 
application, i.e. an application that does not use an epics database.

\subsection{Build}

In directory \textless{}top\textgreater{} execute the command

\begin{verbatim}make
\end{verbatim}NOTE: On systems where GNU make is not the default another command is required, e.g. \verb|gnumake|, \verb|gmake|, etc. See 
you EPICS system administrator.

\subsection{Inspect files}

This time you will see the files generated by make as well as the original files.

\subsection{Run the ioc example}

The example can be run on vxWorks, RTEMS, or on a supported host.

\begin{itemize}
\item On a host, e.g. Linux or Solaris

\begin{itemize}
\item cd \textless{}top\textgreater{}/iocBoot/iocmyexample
\item ../../bin/linux-x86/myexample st.cmd
\end{itemize}
\item vxWorks/RTERMS - Set your boot parameters as described at the end of this chapter and then boot the ioc.
\end{itemize}
After the ioc is started try some of the shell commands (e.g. \verb|dbl| or \verb|dbpr <recordname>|) described in chapter ``IOC 
Test Facilities". In particular run \verb|dbl| to get a list of the records.

The iocsh command interpreter used on non-vxWorks IOCs provides a help facility. Just type:

\begin{verbatim}help\end{verbatim}
or
\begin{verbatim}help <cmd>\end{verbatim}
where \verb|<cmd>| is one of the commands displayed by help.  The help command accepts wildcards, so
\begin{verbatim}help db*\end{verbatim}
will provide information on all commands beginning with the characters db.
On vxWorks the help facility is available by first typing:

\begin{verbatim}iocsh\end{verbatim}

\section{Channel Access Host Example}

An example host example can be generated by:

\begin{verbatim}
cd <mytop>
<base>/bin/<arch>/makeBaseApp.pl -t caClient caClient
make
\end{verbatim}
(or gnumake, as required by your operating system)

Two channel access examples are provided.

\begin{itemize}\item caExample - This example accepts a pvname, connects and reads the current value for pvname, displays the result 
and terminates. To run this example just type.

\verb|<mytop>/bin/<hostarch>/caExample <pvname>|  where

\begin{itemize}

\item \verb|<mytop>| is the full path name to your application top directory.

\item \verb|<hostarch>| is your host architecture.

\item \verb|<pvname>| is one of the record names displayed by the \verb|dbl| ioc shell command.

\end{itemize}

\item caMonitor - This example accepts a filename, which contains a list of pvnames, each appearing on a separate line. 
It connects to each pv and issues monitor requests. It displays messages for all channel access events, connection 
events, etc.

\end{itemize}\section{iocsh}

Because the vxWorks shell is only available on vxWorks, EPICS base provides iocsh. In the main program it can be 
invoked as follows:

\begin{verbatim}iocsh("filename")
\end{verbatim}or

\begin{verbatim}iocsh(0)
\end{verbatim}If the argument is a filename, the commands in the file are executed and iocsh returns. If the argument is 0 then iocsh goes 
into interactive mode, i.e. it prompts for and executes commands until an exit command is issued.

This shell is described in more detail in Chapter 18, ``IOC Shell" on page249 FIXPAGEEREF.

On vxWorks iocsh is not automatically started. It can be started by just giving the following command to the vxWorks 
shell.

\begin{verbatim}iocsh
\end{verbatim}To get back to the vxWorks shell just say

\begin{verbatim}exit
\end{verbatim}

\section{Building IOC components}

Detailed build rules are given in chapter ``Epics Build Facility". This section describes methods for building most 
components needed for IOC applications. It uses excerpts from the myexampleApp/src/Makefile that is generated by 
makeBaseApp.

The following two types of applications can be built:

\begin{itemize}

\item Support applications

These are applications meant for use by ioc applications. The rules described here install things into one of the 
following directories that are created just below \textless{}top\textgreater{}:

\begin{itemize}

\item include

C include files are installed here. Either header files supplied by the application or header files generated 
from xxxRecord.dbd or xxxMenu.dbd files.

\item dbd

Each file contains some combination of \verb|include|, \verb|recordtype|, \verb|device, driver, and |
registrar database definition commands. The following are installed:

\begin{itemize}

\item xxxRecord.dbd, xxxMenu.dbd files

\item An arbitrary xxx.dbd file

\item ioc applications install a file yyy.dbd generated from file yyyInclude.dbd.

\end{itemize}

\item db

Files containing record instance definitions. 

\item lib/\textless{}arch\textgreater{}

All source modules are compiled and placed in shared or static library (win32 dll)

\end{itemize}

\item IOC applications

These are applications loaded into actual IOCs.

\end{itemize}\subsection{Binding to IOC components}

Because many IOC components are bound only during ioc initialization, some method of linking to the appropriate shared 
and/or static libraries must be provided. The method used for IOCs is to generate, from an xxxInclude.dbd file, a C++ 
program that forces a reference to the appropriate library modules. The following database definitions keywords are used 
for this purpose:

\begin{verbatim}recordtype
device
driver
function
variable
registrar
\end{verbatim}The method also requires that IOC components contain an appropriate epicsExport statement. All components must 
contain the statement:

\begin{verbatim}#include <epicsExport.h>
\end{verbatim}\index{epicsExport}Any component that defines any exported functions must also contain:

\begin{verbatim}#include <registryFunction.h>
\end{verbatim}Each record support module must contain a statement like:

\begin{verbatim}epicsExportAddress(rset,xxxRSET);
\end{verbatim}\index{epicsExportAddress}Each device support module must contain a statement like:

\begin{verbatim}epicsExportAddress(dset,devXxxSoft);
\end{verbatim}\index{epicsExportAddress}Each driver support module must contain a statement like:

\begin{verbatim}epicsExportAddress(drvet,drvXxx);
\end{verbatim}\index{epicsExportAddress}Functions are registered using an \verb|epicsRegisterFunction| macro in the C source file containing the function, along 
with a \verb|function| statement in the application database description file.  The makeBaseApp example thus contains the 
following statements to register a pair of functions for use with a subroutine record:

\index{epicsRegisterFunction}
\index{function}\begin{verbatim}epicsRegisterFunction(mySubInit);
epicsRegisterFunction(mySubProcess);
\end{verbatim}The database definition keyword \verb|variable| forces a reference to an integer or double variable, e.g. debugging variables. 
The xxxInclude.dbd file can contain definitions like:

\index{variable}\begin{verbatim}variable(asCaDebug,int)
variable(myDefaultTimeout,double)
\end{verbatim}The code that defines the variables must include code like:

\begin{verbatim}int asCaDebug = 0;
epicsExportAddress(int,asCaDebug);
\end{verbatim}\index{epicsExportAddress}The keyword \verb|registrar| signifies that the epics component supplies a named registrar function that has the prototype:

\index{registrar}\begin{verbatim}typedef void (*REGISTRAR)(void);
\end{verbatim}This function normally registers things, as described in Chapter 21, ``Registry" on page317 FIXPAGEREF. The makeBaseApp example 
provides a sample iocsh command which is registered with the following registrar function:

\begin{verbatim}static void helloRegister(void) {
    iocshRegister(&helloFuncDef, helloCallFunc);
}
epicsExportRegistrar(helloRegister);
\end{verbatim}\index{iocshRegister}
\index{epicsExportRegistrar}\subsection{Makefile rules}

\subsubsection{Building a support application.}

\begin{verbatim}# xxxRecord.h will be created from xxxRecord.dbd
DBDINC += xxxRecord
DBD += myexampleSupport.dbd

LIBRARY_IOC += myexampleSupport

myexampleSupport_SRCS += xxxRecord.c
myexampleSupport_SRCS += devXxxSoft.c
myexampleSupport_SRCS += dbSubExample.c

myexampleSupport_LIBS += $(EPICS_BASE_IOC_LIBS)
\end{verbatim}The DBDINC rule looks for a file xxxRecord.dbd. From this file a file xxxRecord.h is created and installed into \textless{}top\textgreater{}/
include

The DBD rule finds myexampleSupport.dbd in the source directory and installs it into \textless{}top\textgreater{}/dbd

The LIBRARY\_IOC statement states that a shared/static library should be created and installed into \textless{}top\textgreater{}/lib/\textless{}arch\textgreater{}.

The myexampleSupport\_SRCS statements name all the source files that are compiled and put into the library.

The above statements are all that is needed for building many support applications.

\subsubsection{Building the IOC application}

The following statements build the IOC application:

\begin{verbatim}PROD_IOC = myexample

DBD += myexample.dbd

# myexample.dbd will be made up from these files:
myexample_DBD += base.dbd
myexample_DBD += xxxSupport.dbd
myexample_DBD += dbSubExample.dbd

# <name>_registerRecordDeviceDriver.cpp will be created from <name>.dbd
myexample_SRCS += myexample_registerRecordDeviceDriver.cpp
myexample_SRCS_DEFAULT += myexampleMain.cpp
myexample_SRCS_vxWorks += -nil-

# Add locally compiled object code
myexample_SRCS += dbSubExample.c

#The following adds support from base/src/vxWorks
myexample_OBJS_vxWorks += $(EPICS_BASE_BIN)/vxComLibrary

myexample_LIBS += myexampleSupport
myexample_LIBS += $(EPICS_BASE_IOC_LIBS)
\end{verbatim}PROD\_IOC gives that name of the ioc application, which is named \verb|myexample|. 

The DBD definition myexample.dbd will cause build rules to create the database definition include file 
myexampleInclude.dbd from files in the myexample\_DBD definition. For each filename in the myexample\_DBD 
definition, the created myexampleInclude.dbd will contain an include statement for that filename. The created 
myexampleInclude.dbd file will contain the following lines.

\begin{verbatim}include "base.dbd"
include "xxxSupport.dbd"
include "dbSubExample.dbd"
\end{verbatim}When the DBD build rules find the created file \verb|myexampleInclude.dbd|, the rules then call dbExpand which reads 
\verb|myexampleInclude.dbd |to generate file \verb|myexample.dbd|, and install it into \verb|<top>/dbd.|

An arbitrary number of \verb|myexample_SRCS| statements can be given. One, \\
\verb|myexample_registerRecordDeviceDriver.cpp,| is special. When this is seen the following happens:

\begin{itemize}\item A perl script \verb|registerRecordDeviceDriver.pl| is executed. Taking myexample.dbd as input it generates 
\verb|myexample_registerRecordDeviceDriver.cpp|.

\end{itemize}\section{makeBaseApp}

makeBaseApp is a perl script that creates application areas. It can create the following:

\begin{itemize}\item \textless{}top\textgreater{}/Makefile

\item \textless{}top\textgreater{}/configure - This directory contains the files needed by the EPICS build system.

\item  \textless{}top\textgreater{}/xxxApp - A set of directories and associated files for a  major sub-module.

\item \textless{}top\textgreater{}/iocBoot - A subdirectory and associated files.

\item  \textless{}top\textgreater{}/iocBoot/iocxxx - A subdirectory and files for a single ioc.

\end{itemize}makeBaseApp creates directories and then copies template files into the newly created directories while expanding 
macros in the template files. EPICS base provides two sets of template files: simple and example. These are meant for 
simple applications. Each site, however, can create its own set of template files which may provide additional 
functionality. This section describes the functionality of makeBaseApp itself, the next section provides details about the 
simple and example templates.

\subsection{Usage}

makeBaseApp has four possible forms of command line:

\begin{verbatim}<base>/bin/<arch>/makeBaseApp.pl -h
\end{verbatim} Provides help.

\begin{verbatim}<base>/bin/<arch>/makeBaseApp.pl -l [options]
\end{verbatim} List the application templates available. This invocation does not alter the current directory.

\begin{verbatim}<base>/bin/<arch>/makeBaseApp.pl [-t type] [options] app ... 
\end{verbatim}Create application directories.

\begin{verbatim}<base>/bin/<arch>/makeBaseApp.pl -i -t type [options] ioc ... 
\end{verbatim}Create ioc boot directories.

Options for all command forms:

\begin{verbatim}-b base     
\end{verbatim}\begin{description}\item Provides the full path to EPICS base. If not specified, the value is taken from the EPICS\_BASE entry in config/
RELEASE. If the config directory does not exist, the path is taken from the command-line that was used to invoke 
makeBaseApp

\end{description}\begin{verbatim}-T template     
\end{verbatim}\begin{description}\item Set the template top directory (where the application templates are). If not specified, the template path is taken 
from the TEMPLATE\_TOP entry in config/RELEASE. If the config directory does not exist the path is taken from 
the environment variable EPICS\_MBA\_TEMPLATE\_TOP, or if this is not set the templates from EPICS base are 
used.

\end{description}\begin{verbatim}-d 
\end{verbatim}\begin{description}\item Verbose output (useful for debugging)

\end{description}Arguments unique to \verb|makeBaseApp.pl [-t type] [options] app ...|:

\begin{verbatim}app     
\end{verbatim}\begin{description}\item One or more application names (the created directories will have `` App" appended to this name)

\end{description}\begin{verbatim}-t type     
\end{verbatim}\begin{description}\item Set the template type (use the -l invocation to get a list of valid types). If this option is not used, type is taken from 
the environment variable EPICS\_MBA\_DEF\_APP\_TYPE, or if that is not set the values ``default" and then 
"example `` are tried.

\end{description}Arguments unique to \verb|makeBaseApp.pl -i [options] ioc ...|:

\begin{verbatim}ioc 
\end{verbatim}One or more IOC names (the created directories will have ``ioc `` prepended to this name).

\begin{verbatim}-a arch     
\end{verbatim}\begin{description}\item Set the IOC architecture (e.g. vxWorks-68040).  If\verb| -a arch |is not specified, you will be prompted.

\end{description}\subsection{Environment Variables:}

\begin{verbatim}EPICS_MBA_DEF_APP_TYPE
\end{verbatim}\begin{description}\item Application type you want to use as default

\end{description}\begin{verbatim}EPICS_MBA_TEMPLATE_TOP
\end{verbatim}\begin{description}\item Template top directory

\end{description}\subsection{Description}

To create a new \textless{}top\textgreater{} issue the commands:

\begin{verbatim}mkdir <top>
cd <top>
<base>/bin/<arch>/makeBaseApp.pl -t <type> <app> ... 
<base>/bin/<arch>/makeBaseApp.pl -i -t <type> <ioc> ...
\end{verbatim}makeBaseApp does the following:

\begin{itemize}

\item EPICS\_BASE is located by checking the following in order:

\begin{itemize}

\item If the -b option is specified it is used.

\item If a \verb|<top>/config/RELEASE| file exists and defines a value for \verb|EPICS_BASE| it is used.

\item It is obtained from the invocation of makeBaseApp. For this to work, the full path name to the 
makeBaseApp.pl script in the EPICS base release you are using must be given.

\end{itemize}\item TEMPLATE\_TOP is located in a similar fashion:

\begin{itemize}

\item If the -T option is specified it is used.

\item If a \verb|<top>/config/RELEASE| file exists and defines a value for TEMPLATE\_TOP it is used.

\item If EPICS\_MBA\_TEMPLATE\_TOP is defined it is used.

\item It is set equal to \verb|<epics_base>/templates/makeBaseApp/top|

\end{itemize}

\item If -l is specified the list of application types is listed and makeBaseApp terminates.

\item If -i is specified and -a is not then the user is prompted for the IOC architecture.

\item The application type is determined by checking the following in order:

\begin{itemize}

\item If -t is specified it is used.

\item If EPICS\_MBA\_DEF\_APP\_TYPE is defined it is used.

\item If a template \verb|defaultApp| exists, the application type is set equal to default.

\item If a template \verb|exampleApp| exists, the application type is set equal to example.

\end{itemize}

\item If the application type is not found in TEMPLATE\_TOP, makeBaseApp issues an error and terminates.

\item If Makefile does not exist, it is created.

\item If directory \verb|configure| does not exist, it is created and populated with all the \verb|configure| files.

\item If -i is specified:

\begin{itemize}

\item If directory \verb|iocBoot| does not exist, it is created and the files from the template boot directory are copied 
into it.

\item For each \verb|<ioc> |specified on the command line a directory iocBoot/ioc\textless{}ioc\textgreater{} is created and populated with 
the files from the template (with ReplaceLine() tag replacement, see below).

\end{itemize}

\item If -i is NOT specified:

\begin{itemize}

\item For each \verb|<app>| specified on the command line a directory \textless{}app\textgreater{}App is created and populated with the 
directory tree from the template (with ReplaceLine() tag replacement, see below).
\end{itemize}
\end{itemize}

\subsection{Tag Replacement within a Template}

When copying certain files from the template to the new application structure, makeBaseApp replaces some predefined 
tags in the name or text of the files concerned with values that are known at the time. An application template can extend 
this functionality as follows:

\begin{itemize}

\item Two perl subroutines are defined within makeBaseApp:

\begin{itemize}

\item ReplaceFilename - This substitutes for the following in names of any file taken from the templates.                 

\begin{itemize}

\item \_APPNAME\_  

\item \_APPTYPE\_

\end{itemize}

\item ReplaceLine - This substitutes for the following in each line of each file taken from the templates:                 
\begin{itemize}

\item \_USER\_  

\item  \_EPICS\_BASE\_ 

\item  \_ARCH\_ 

\item  \_APPNAME\_ 

\item  \_APPTYPE\_ 

\item  \_TEMPLATE\_TOP\_ 

\item  \_IOC\_ 

\end{itemize}

\end{itemize}

\item If the application type directory has a file named \verb|Replace.pl|, it can:

\begin{itemize}

\item Replace one or both of the above subroutines with its own versions.

\item Add a subroutine \verb|ReplaceFilenameHook($file)| which is called at the end of \verb|ReplaceFilename|. 

\item Add a subroutine \verb|ReplaceLineHook($line)| which is called at the end of \verb|ReplaceLine|.

\item Include other code which is run after the command line options are interpreted.

\end{itemize}

\end{itemize}


\subsection{makeBaseApp templetes provided with base}

\subsubsection{support}

This creates files appropriate for building a support application.

\subsubsection{ioc}

 Without the -i option, this creates files appropriate for building an ioc application, With the -i option it creates an ioc boot 
directory.

\subsubsection{example}

Without the -i option it creates files for running an example. Both a support and an ioc application are built. With the -i 
option it creates an ioc boot directory that can be used to run the example.

\subsubsection{caClient}

This builds two Channel Access clients.

\subsubsection{caServer}

This builds an example Portable Access Server.

\section{vxWorks boot parameters}

The vxWorks boot parameters are set via the console serial port on your IOC. Life is much easier if you find out how to 
connect the serial port to a window on your workstation.

The vxWorks boot parameters look something like the following:

\begin{verbatim}
boot device            : xxx
processor number       : 0
host name              : xxx
file name              : <full path to board support>/vxWorks
inet on ethernet (e)   : xxx.xxx.xxx.xxx:<netmask>
host inet (h)          : xxx.xxx.xxx.xxx
user (u)               : xxx
ftp password (pw)      : xxx
flags (f)              : 0x0
target name (tn)       : <hostname for this inet address>
startup script (s)     : <top>/iocBoot/iocmyexample/st.cmd
\end{verbatim}
The actual values for each field are site and IOC dependent. Two fields that you can change at will are the vxWorks boot 
image and the location of the startup script.

Note that the full path name for the correct board support boot image must be specified. If bootp is used the same 
information will need to be placed in the bootp host's configuration database instead.

When your boot parameters are set properly, just press the reset button on your IOC, or use the @ command to commence 
booting. You will find it VERY convenient to have the console port of the IOC attached to a scrolling window on your 
workstation.

\section{RTEMS boot procedure}

RTEMS uses the vendor-supplied bootstrap mechanism so the method for booting an IOC depends upon the hardware in 
use.

\subsection{Booting from a BOOTP/DHCP/TFTP server}

Many boards can use BOOTP/DHCP to read their network configuration and then use TFTP to read the applicaion 
program.  RTEMS can then use TFTP or NFS to read startup scripts and configuration files. If you are using TFTP to read 
the startup scripts and configuration files you must install the EPICS application files on your TFTP server as follows:

\begin{itemize}\item Copy all db/xxx files to \textless{}tftpbase\textgreater{}/epics/\textless{}target\_hostname\textgreater{}/db/xxx.

\item Copy all dbd/xxx files to \textless{}tftpbase\textgreater{}/epics/\textless{}target\_hostname\textgreater{}/dbd/xxx.

\item Copy the st.cmd script  to \textless{}tftpbase\textgreater{}/epics/\textless{}target\_hostname\textgreater{}/st.cmd.

\end{itemize}Use DHCP site-specific option 129 to specify the path to the IOC startup script.

\subsection{Motorola PPCBUG boot parameters}

\index{PPCBUG}Motrola single-board computers which employ PPCBUG should have their `NIOT' parameters set up like:

\noindent
\verb|Controller LUN =00|\\
\verb|Device LUN     =00|\\
\verb|Node Control Memory Address =FFE10000|\\
\verb|Client IP Address      =|`Dotted-decimal' IP address of IOC\\
\verb|Server IP Address      =|`Dotted-decimal' IP address of TFTP/NFS server\\
\verb|Subnet IP Address Mask =|`Dotted-decimal' IP address of subnet mask (255.255.255.0 for class C subnet)\\
\verb|Broadcast IP Address   =|`Dotted-decimal' IP address of subnet broadcast address\\
\verb|Gateway IP Address     =|`Dotted-decimal' IP address of network gateway (0.0.0.0 if none)\\
\verb|Boot File Name         =|Path to application bootable image (..../bin/RTEMS-mvme2100/test.boot)\\
\verb|Argument File Name     =|Path to application startup script (..../iocBoot/ioctest/st.cmd)\\
\verb|Boot File Load Address         =001F0000| (actual value depends on BSP)\\
\verb|Boot File Execution Address    =001F0000| (actual value depends on BSP)\\
\verb|Boot File Execution Delay      =00000000|\\
\verb|Boot File Length               =00000000|\\
\verb|Boot File Byte Offset          =00000000|\\
\verb|BOOTP/RARP Request Retry       =00      |\\
\verb|TFTP/ARP Request Retry         =00      |\\
\verb|Trace Character Buffer Address =00000000|

\subsection{Motorola MOTLOAD boot parameters}

\index{MOTLOAD}Motrola single-board computers which employ MOTLOAD should have their network `Global Environment Variable' 
parameters set up like:

\noindent
\verb|mot-/dev/enet0-cipa=|`Dotted-decimal' IP address of IOC\\
\verb|mot-/dev/enet0-sipa=|`Dotted-decimal' IP address of TFTP/NFS server\\
\verb|mot-/dev/enet0-snma=|`Dotted-decimal' IP address of subnet mask (255.255.255.0 for class C subnet)\\
\verb|mot-/dev/enet0-gipa=|`Dotted-decimal' IP address of network gateway (omit if none)\\
\verb|mot-/dev/enet0-file=|Path to application bootable image (..../bin/RTEMS-mvme5500/test.boot)\\
\verb|rtems-client-name=|IOC name (mot-/dev/enet0-cipa will be used if this parameter is missing)\\
\verb|rtems-dns-server=|'Dotted-decimal' IP address of domain name server (omit if none)\\
\verb|rtems-dns-domainname=|Domain name (if this parameter is omitted the compiled-in value will be used)\\
\verb|epics-script=|Path to application startup script (..../iocBoot/ioctest/st.cmd)

The \verb|mot-script-boot| parameter should be set up like:

\begin{verbatim}
tftpGet -a4000000 -cxxx -sxxx -mxxx -gxxx -d/dev/enet0
        -f..../bin/RTEMS-mvme5500/test.boot
netShut
go -a4000000
\end{verbatim}
where the -c, -s, -m and -g values should match the cipa, sipa, snma and gipa values, 
respectively and the -f value should match the file value.

\subsection{RTEMS NFS access}

For IOCs which use NFS for remote file access the EPICS initialization code uses the startup script pathname to 
determine the parameters for the initial NFS mount.  If the startup script pathname begins with a `\verb|/|' the first component 
of the pathname is used as both the server path and the local mount point. If the startup script pathname does not begin 
with a `\verb|/|' the first component of the pathname is used as the local mount point and the server path is `'\verb|/tftpboot/|'' 
followed by the first component of the pathname.  This allows the NFS client used for EPICS file access and the TFTP 
client used for bootstrapping the application to have a similar view of the remote filesystem.

\subsection{RTEMS `Cexp'}

\index{Cexp}The RTEMS `Cexp' add-on package provides the ability to load object modules at application run-time.  If your RTEMS 
build includes this package you can load RTEMS IOC applications in the same fashion as vxWorks IOC applications.




