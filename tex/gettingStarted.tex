\chapter{Getting Started}

\section{Introduction}

This chapter provides a brief introduction to creating EPICS IOC applications. It contains:

\begin{itemize}
\item Instructions for creating, building, and running an example IOC application.

\item Instructions for creating, building, and executing example Channel Access clients.

\item Briefly describes iocsh, which is a base supplied command shell.

\item Describes rules for building IOC components.

\item Describes makeBaseApp.pl, which is a perl script that generates files for building applications.

\item Briefly discusses vxWorks boot parameters
\end{itemize}

This chapter will be hard to understand unless you have some familarity with IOC concepts such as record types, device and driver support and have had some experience with creating ioc databases.
Once you have this experience, this chapter provides most of the information needed to build applications.
The example that follows assumes that EPICS base has already been built.

\section{Example IOC Application}
\label{Example IOC Application}

\index{Example IOC Application}
This section explains how to create an example IOC application in a directory \verb|<top>|, naming the application 
\verb|myexampleApp| and the ioc directory \verb|iocmyexample|.

\subsection{Check that \texttt{EPICS\_HOST\_ARCH} is defined}

Execute the command:

\begin{verbatim}
echo $EPICS_HOST_ARCH         (Unix/Linux)
\end{verbatim}
or
\begin{verbatim}
set EPICS_HOST_ARCH             (Windows)
\end{verbatim}

This should display your workstation architecture, for example \verb|linux-x86| or \verb|win32-x86|. If you get an ``Undefined 
variable" error, you should set \verb|EPICS_HOST_ARCH| to your host operating system followed by a dash and then your host 
architecture, e.g.  \verb|solaris-sparc|. The perl script \verb|EpicsHostArch.pl| in the base/startup directory has been provided to help 
set \verb|EPICS_HOST_ARCH|.

\subsection{Create the example application}

The following commands create an example application.

\begin{verbatim}
mkdir <top>
cd <top>
<base>/bin/<arch>/makeBaseApp.pl -t example myexample
<base>/bin/<arch>/makeBaseApp.pl -i -t example myexample
\end{verbatim}

Here, \verb|<arch>| indicates the operating system architecture of your computer.  For example, \verb|solaris-sparc|. The last command 
will ask you to enter an architecture for the IOC. It provides a list of architectures for which base has been built.

The full path name to \verb|<base>| (an already built copy of EPICS base) must be given. Check with your EPICS system 
administrator to see what the path to your \verb|<base>| is. For example:

\begin{verbatim}
/home/phoebus/MRK/epics/base/bin/linux-x86/makeBaseApp.pl ...
\end{verbatim}

Windows Users Note: Perl scripts must be invoked with the command \verb|perl <scriptname>| on Windows. Perl script names are 
case sensitive. For example to create an application on Windows:

\begin{verbatim}
perl C:\epics\base\bin\win32-x86\makeBaseApp.pl -t example myexample
\end{verbatim}

\subsection{Inspect files}

Spend some time looking at the files that appear under \verb|<top>|. Do this \emph{before} building. This allows you to see typical 
files which are needed to build an application without seeing the files generated by make.

\subsection{Sequencer Example}

The sequencer is now supported as an unbundled product. The example includes an example state notation program,
\verb|sncExample.stt|. As created by makeBaseApp the example is not built or executed.

Before \verb|sncExample.stt| can be compiled, the sequencer module must have been built using the same version of base that the example uses.

To build sncExample edit the following files:

\begin{itemize}
\item \verb|configure/RELEASE| -- Set SNCSEQ to the location of the sequencer.
\item \verb|iocBoot/iocmyexample/st.cmd| -- Remove the comment character \# from this line:

\verb|#seq sncExample, "user=<user>"|
\end{itemize}

The Makefile contains commands for building the sncExample code both as a component of the example IOC application
and as a standalone program called \verb|sncProgram|, an executable that connects through Channel Access to a separate IOC database.

\subsection{Build}

In directory \verb|<top>| execute the command

\begin{verbatim}
make
\end{verbatim}

NOTE: On systems where GNU make is not the default another command is required, e.g. \verb|gnumake|, \verb|gmake|, etc. See 
you EPICS system administrator.

\subsection{Inspect files}

This time you will see the files generated by make as well as the original files.

\subsection{Run the ioc example}

The example can be run on vxWorks, RTEMS, or on a supported host.

\begin{itemize}
\item On a host, e.g. Linux or Solaris

\begin{verbatim}
cd <top>/iocBoot/iocmyexample
../../bin/linux-x86/myexample st.cmd
\end{verbatim}

\item vxWorks/RTERMS -- Set your boot parameters as described at the end of this chapter and then boot the ioc.
\end{itemize}

After the ioc is started try some of the shell commands (e.g. \verb|dbl| or \verb|dbpr <recordname>|) described in the chapter ``IOC 
Test Facilities". In particular run \verb|dbl| to get a list of the records.

The iocsh command interpreter used on non-vxWorks IOCs provides a help facility. Just type:

\begin{verbatim}
help
\end{verbatim}
or
\begin{verbatim}
help <cmd>
\end{verbatim}
where \verb|<cmd>| is one of the commands displayed by help.  The help command accepts wildcards, so
\begin{verbatim}
help db*
\end{verbatim}
will provide information on all commands beginning with the characters db.
On vxWorks the help facility is available by first typing:

\begin{verbatim}
iocsh
\end{verbatim}

\section{Channel Access Host Example}

An example host example can be generated by:

\begin{verbatim}
cd <mytop>
<base>/bin/<arch>/makeBaseApp.pl -t caClient caClient
make
\end{verbatim}
(or gnumake, as required by your operating system)

Two channel access examples are provided:

\begin{description}
\item \verb|caExample| \\
This example program expects a pvname argument, connects and reads the current value for the pv, displays the result 
and terminates. To run this example just type.

\verb|<mytop>/bin/<hostarch>/caExample <pvname>|  where

\begin{itemize}
\item \verb|<mytop>| is the full path name to your application top directory.

\item \verb|<hostarch>| is your host architecture.

\item \verb|<pvname>| is one of the record names displayed by the \verb|dbl| ioc shell command.
\end{itemize}

\item \verb|caMonitor| \\
This example program expects a filename argument which contains a list of pvnames, each appearing on a separate line.
It connects to each pv and issues monitor requests.
It displays messages for all channel access events, connection events, etc.
\end{description}

\section{iocsh}

Because the vxWorks shell is only available on vxWorks, EPICS base provides iocsh.
In the main program it can be invoked as follows:

\begin{verbatim}
iocsh("filename")
\end{verbatim}
or
\begin{verbatim}
iocsh(0)
\end{verbatim}
If the argument is a filename, the commands in the file are executed and iocsh returns.
If the argument is 0 then iocsh goes into interactive mode, i.e. it prompts for and executes commands until an exit command is issued.

This shell is described in more detail in Chapter \ref{chap:IOC Shell}, ``IOC Shell".

On vxWorks iocsh is not automatically started.
It can be started by just giving the following command to the vxWorks shell.

\begin{verbatim}
iocsh
\end{verbatim}
To get back to the vxWorks shell just say

\begin{verbatim}
exit
\end{verbatim}

\section{Building IOC components}

Detailed build rules are given in chapter \ref{chap:Build Facility} ``Build Facility".
This section describes methods for building most components needed for IOC applications.
It uses excerpts from the \verb|myexampleApp/src/Makefile| that is generated by 
makeBaseApp.

The following two types of applications can be built:

\begin{itemize}
\item Support applications

These are applications meant for use by ioc applications.
The rules described here install things into one of the following directories that are created just below \verb|<top>|:

\begin{description}
\item \verb|include| \\
C include files are installed here. Either header files supplied by the application or header files generated 
from \verb|xxxRecord.dbd| or \verb|xxxMenu.dbd| files.

\item \verb|dbd| \\
Each file contains some combination of \verb|include|, \verb|recordtype|, \verb|device|, \verb|driver|, and
\verb|registrar| database definition commands. The following are installed:

\begin{itemize}
\item \verb|xxxRecord.dbd| and \verb|xxxMenu.dbd| files
\item An arbitrary \verb|xxx.dbd| file
\item ioc applications install a file \verb|yyy.dbd| generated from file \verb|yyyInclude.dbd|.
\end{itemize}

\item \verb|db| \\
Files containing record instance definitions.

\item \verb|lib/<arch>| \\
All source modules are compiled and placed in shared or static library (win32 dll)

\end{description}

\item IOC applications

These are applications loaded into actual IOCs.

\end{itemize}

\subsection{Binding to IOC components}

Because many IOC components are bound only during ioc initialization, some method of linking to the appropriate shared and/or static libraries must be provided.
The method used for IOCs is to generate, from an \verb|xxxInclude.dbd| file, a C++ program that contains references to the appropriate library modules.
The following database definitions keywords are used for this purpose:

\begin{verbatim}
recordtype
device
driver
function
variable
registrar
\end{verbatim}

\index{epicsExport}
The method also requires that IOC components contain an appropriate epicsExport statement.
All components must contain the statement:

\begin{verbatim}
#include <epicsExport.h>
\end{verbatim}

Any component that defines any exported functions must also contain:

\begin{verbatim}
#include <registryFunction.h>
\end{verbatim}

Each record support module must contain a statement like:

\index{epicsExportAddress}
\begin{verbatim}
epicsExportAddress(rset,xxxRSET);
\end{verbatim}

Each device support module must contain a statement like:

\begin{verbatim}
epicsExportAddress(dset,devXxxSoft);
\end{verbatim}

Each driver support module must contain a statement like:

\index{epicsExportAddress}
\begin{verbatim}
epicsExportAddress(drvet,drvXxx);
\end{verbatim}

Functions are registered using an \verb|epicsRegisterFunction| macro in the C source file containing the function, along with a \verb|function| statement in the application database description file.
The makeBaseApp example thus contains the following statements to register a pair of functions for use with a subroutine record:

\index{epicsRegisterFunction}
\index{function}
\begin{verbatim}
epicsRegisterFunction(mySubInit);
epicsRegisterFunction(mySubProcess);
\end{verbatim}

The database definition keyword \verb|variable| forces a reference to an integer or double variable, e.g. debugging variables.
The \verb|xxxInclude.dbd| file can contain definitions like:

\index{variable}
\begin{verbatim}
variable(asCaDebug,int)
variable(myDefaultTimeout,double)
\end{verbatim}

The code that defines the variables must include code like:

\index{epicsExportAddress}
\begin{verbatim}
int asCaDebug = 0;
epicsExportAddress(int,asCaDebug);
\end{verbatim}

\index{registrar}
The keyword \verb|registrar| signifies that the epics component supplies a named registrar function that has the prototype:

\begin{verbatim}
typedef void (*REGISTRAR)(void);
\end{verbatim}

This function normally registers things, as described in Chapter \ref{Registry}, ``Registry" on page \pageref{Registry}. The makeBaseApp example
provides a sample iocsh command which is registered with the following registrar function:

\index{iocshRegister}
\index{epicsExportRegistrar}
\begin{verbatim}
static void helloRegister(void) {
    iocshRegister(&helloFuncDef, helloCallFunc);
}
epicsExportRegistrar(helloRegister);
\end{verbatim}

\subsection{Makefile rules}

\subsubsection{Building a support application.}

\begin{verbatim}
# xxxRecord.h will be created from xxxRecord.dbd
DBDINC += xxxRecord
DBD += myexampleSupport.dbd

LIBRARY_IOC += myexampleSupport

myexampleSupport_SRCS += xxxRecord.c
myexampleSupport_SRCS += devXxxSoft.c
myexampleSupport_SRCS += dbSubExample.c

myexampleSupport_LIBS += $(EPICS_BASE_IOC_LIBS)
\end{verbatim}

The \verb|DBDINC| rule looks for a file \verb|xxxRecord.dbd|.
From this file a file \verb|xxxRecord.h| is created and installed into \verb|<top>/include|

The \verb|DBD| rule finds \verb|myexampleSupport.dbd| in the source directory and installs it into \verb|<top>/dbd|

The \verb|LIBRARY_IOC| variable requests that a library be created and installed into \verb|<top>/lib/<arch>|

The \verb|myexampleSupport_SRCS| statements name all the source files that are compiled and put into the library.

The above statements are all that is needed for building many support applications.

\subsubsection{Building the IOC application}

The following statements build the IOC application:

\begin{verbatim}
PROD_IOC = myexample

DBD += myexample.dbd

# myexample.dbd will be made up from these files:
myexample_DBD += base.dbd
myexample_DBD += xxxSupport.dbd
myexample_DBD += dbSubExample.dbd

# <name>_registerRecordDeviceDriver.cpp will be created from <name>.dbd
myexample_SRCS += myexample_registerRecordDeviceDriver.cpp
myexample_SRCS_DEFAULT += myexampleMain.cpp
myexample_SRCS_vxWorks += -nil-

# Add locally compiled object code
myexample_SRCS += dbSubExample.c

# Add support from base/src/vxWorks if needed
myexample_OBJS_vxWorks += $(EPICS_BASE_BIN)/vxComLibrary

myexample_LIBS += myexampleSupport
myexample_LIBS += $(EPICS_BASE_IOC_LIBS)
\end{verbatim}

\verb|PROD_IOC| sets the name of the ioc application, here called \verb|myexample|.

The DBD definition \verb|myexample.dbd| will cause build rules to create the database definition include file \\
\verb|myexampleInclude.dbd| from files in the \verb|myexample_DBD| definition. For each filename in that
definition, the created \verb|myexampleInclude.dbd| will contain an include statement for that filename.
In this case the created \verb|myexampleInclude.dbd| file will contain the following lines.

\begin{verbatim}
include "base.dbd"
include "xxxSupport.dbd"
include "dbSubExample.dbd"
\end{verbatim}

When the DBD build rules find the created file \verb|myexampleInclude.dbd|, the rules then call dbExpand which reads 
\verb|myexampleInclude.dbd| to generate file \verb|myexample.dbd|, and install it into \verb|<top>/dbd|.

An arbitrary number of \verb|myexample_SRCS| statements can be given. Names of the form \\
\verb|<name>_registerRecordDeviceDriver.cpp,| are special; when they are seen the perl script \\
\verb|registerRecordDeviceDriver.pl| is executed and given \verb|<name>.dbd| as input.  This script generates the
\verb|<name>_registerRecordDeviceDriver.cpp| file automatically.

\index{makeBaseApp.pl}
\section{makeBaseApp.pl}

\verb|makeBaseApp.pl| is a perl script that creates application areas. It can create the following:

\begin{itemize}
\item \verb|<top>/Makefile|
\item \verb|<top>/configure| -- This directory contains the files needed by the EPICS build system.
\item \verb|<top>/xxxApp| -- A set of directories and associated files for a  major sub-module.
\item \verb|<top>/iocBoot| -- A subdirectory and associated files.
\item \verb|<top>/iocBoot/iocxxx| -- A subdirectory and files for a single ioc.
\end{itemize}

\verb|makeBaseApp.pl| creates directories and then copies template files into the newly created directories while expanding macros in the template files.
EPICS base provides two sets of template files: simple and example.
These are meant for simple applications.
Each site, however, can create its own set of template files which may provide additional functionality.
This section describes the functionality of makeBaseApp itself, the next section provides details about the simple and example templates.

\subsection{Usage}

makeBaseApp has four possible forms of command line:

\begin{verbatim}
<base>/bin/<arch>/makeBaseApp.pl -h
\end{verbatim}
Provides help.

\begin{verbatim}
<base>/bin/<arch>/makeBaseApp.pl -l [options]
\end{verbatim}
List the application templates available. This invocation does not alter the current directory.

\begin{verbatim}
<base>/bin/<arch>/makeBaseApp.pl [-t type] [options] app ... 
\end{verbatim}
Create application directories.

\begin{verbatim}
<base>/bin/<arch>/makeBaseApp.pl -i -t type [options] ioc ... 
\end{verbatim}
Create ioc boot directories.

Options for all command forms:

\begin{description}
\item \verb|-b base| \\
Provides the full path to EPICS base.
If not specified, the value is taken from the EPICS\_BASE entry in config/RELEASE.
If the config directory does not exist, the path is taken from the command-line that was used to invoke makeBaseApp

\item \verb|-T template| \\
Set the template top directory (where the application templates are).
If not specified, the template path is taken from the TEMPLATE\_TOP entry in config/RELEASE.
If the config directory does not exist the path is taken from the environment variable EPICS\_MBA\_TEMPLATE\_TOP, or if this is not set the templates from EPICS base are used.

\item \verb|-d| \\
Verbose output (useful for debugging)
\end{description}

Arguments unique to \verb|makeBaseApp.pl [-t type] [options] app ...|:

\begin{description}
\item \verb|app| \\
One or more application names (the created directories will have ``App" appended to this name)

\item \verb|-t type| \\
Set the template type (use the \verb|-l| invocation to get a list of valid types).
If this option is not used, type is taken from the environment variable EPICS\_MBA\_DEF\_APP\_TYPE, or if that is not set the values ``default" and then ``example" are tried.
\end{description}

Arguments unique to \verb|makeBaseApp.pl -i [options] ioc ...|:

\begin{description}
\item \verb|ioc| \\
One or more IOC names (the created directories will have ``ioc'' prepended to this name).

\item \verb|-a arch| \\
Set the IOC architecture (e.g. vxWorks-68040).
If \verb|-a arch| is not specified, you will be prompted.
\end{description}

\subsection{Environment Variables:}

\begin{description}
\item \verb|EPICS_MBA_DEF_APP_TYPE| \\
Application type you want to use as default

\item \verb|EPICS_MBA_TEMPLATE_TOP| \\
Template top directory
\end{description}

\subsection{Description}

To create a new \verb|<top>| issue the commands:

\begin{verbatim}
mkdir <top>
cd <top>
<base>/bin/<arch>/makeBaseApp.pl -t <type> <app> ... 
<base>/bin/<arch>/makeBaseApp.pl -i -t <type> <ioc> ...
\end{verbatim}

makeBaseApp does the following:

\begin{itemize}
\item \verb|EPICS_BASE| is located by checking the following in order:

\begin{itemize}
\item If the \verb|-b| option is specified its value is used.

\item If a \verb|<top>/configure/RELEASE| file exists and defines a value for \verb|EPICS_BASE| it is used.

\item It is obtained from the invocation of the makeBaseApp program.
For this to work, the full path name to the \verb|makeBaseApp.pl| script in the EPICS base release you are using must be given.
\end{itemize}

\item \verb|TEMPLATE_TOP| is located in a similar fashion:

\begin{itemize}
\item If the \verb|-T| option is specified its value is used.

\item If a \verb|<top>/configure/RELEASE| file exists and defines a value for \verb|TEMPLATE_TOP| it is used.

\item If \verb|EPICS_MBA_TEMPLATE_TOP| is defined its value is used.

\item It is set equal to \verb|<epics_base>/templates/makeBaseApp/top|
\end{itemize}

\item If \verb|-l| is specified the list of application types is listed and makeBaseApp terminates.

\item If \verb|-i| is specified and \verb|-a| is not then the user is prompted for the IOC architecture.

\item The application type is determined by checking the following in order:

\begin{itemize}
\item If \verb|-t| is specified it is used.

\item If \verb|EPICS_MBA_DEF_APP_TYPE| is defined its value is used.

\item If a template \verb|defaultApp| exists, the application type is set equal to default.

\item If a template \verb|exampleApp| exists, the application type is set equal to example.
\end{itemize}

\item If the application type is not found in \verb|TEMPLATE_TOP|, makeBaseApp issues an error and terminates.

\item If \verb|Makefile| does not exist, it is created.

\item If directory \verb|configure| does not exist, it is created and populated with all the \verb|configure| files.

\item If \verb|-i| is specified:

\begin{itemize}
\item If directory \verb|iocBoot| does not exist, it is created and the files from the template boot directory are copied 
into it.

\item For each \verb|<ioc>| specified on the command line a directory \verb|iocBoot/ioc<ioc>| is created and populated with the files from the template (with \verb|ReplaceLine()| tag replacement, see below).
\end{itemize}

\item If \verb|-i| is NOT specified:

\begin{itemize}
\item For each \verb|<app>| specified on the command line a directory \verb|<app>App| is created and populated with the directory tree from the template (with \verb|ReplaceLine()| tag replacement, see below).
\end{itemize}
\end{itemize}

\subsection{Tag Replacement within a Template}

When copying certain files from the template to the new application structure, makeBaseApp replaces some predefined tags in the name or text of the files concerned with values that are known at the time.
An application template can extend this functionality as follows:

\begin{itemize}
\item Two perl subroutines are defined within makeBaseApp:

\begin{description}
\item \verb|ReplaceFilename| \\
This substitutes for the following in names of any file taken from the templates.

\begin{verbatim}
    _APPNAME_
    _APPTYPE_
\end{verbatim}

\item \verb|ReplaceLine| \\
This substitutes for the following in each line of each file taken from the templates:

\begin{verbatim}
    _USER_
    _EPICS_BASE_
    _ARCH_
    _APPNAME_
    _APPTYPE_
    _TEMPLATE_TOP_
    _IOC_
\end{verbatim}
\end{description}

\item If the application type directory has a file named \verb|Replace.pl|, this file may:

\begin{itemize}
\item Replace one or both of the above subroutines with its own versions.

\item Provide a subroutine \verb|ReplaceFilenameHook($file)| which will be called at the end of the subroutine \verb|ReplaceFilename| described above.

\item Provide a subroutine \verb|ReplaceLineHook($line)| which is called at the end of \verb|ReplaceLine|.

\item Include other code which is run after the command line options have been interpreted.
\end{itemize}
\end{itemize}


\subsection{makeBaseApp templetes provided with base}

\subsubsection{support}

This creates files appropriate for building a support application.

\subsubsection{ioc}

Without the \verb|-i| option, this creates files appropriate for building an ioc application.
With the \verb|-i| option it creates an ioc boot directory.

\subsubsection{example}

Without the \verb|-i| option it creates files for running an example.
Both a support and an ioc application are built.
With the \verb|-i| option it creates an ioc boot directory that can be used to run the example.

\subsubsection{caClient}

This builds two Channel Access clients.

\subsubsection{caServer}

This builds an example Portable Access Server.

\section{vxWorks boot parameters}

The vxWorks boot parameters are set via the console serial port on your IOC.
Life is much easier if you can connect the console to a terminal window on your workstation.
On Linux the `screen' program lets you communicate through a local serial port; run \verb|screen /dev/ttyS0| if the IOC is connected to \verb|ttyS0|.

The vxWorks boot parameters look something like the following:

\begin{verbatim}
boot device            : xxx
processor number       : 0
host name              : xxx
file name              : <full path to board support>/vxWorks
inet on ethernet (e)   : xxx.xxx.xxx.xxx:<netmask>
host inet (h)          : xxx.xxx.xxx.xxx
user (u)               : xxx
ftp password (pw)      : xxx
flags (f)              : 0x0
target name (tn)       : <hostname for this inet address>
startup script (s)     : <top>/iocBoot/iocmyexample/st.cmd
\end{verbatim}
The actual values for each field are site and IOC dependent.
Two fields that you can change at will are the vxWorks boot image and the location of the startup script.

Note that the full path name for the correct board support boot image must be specified.
If bootp is used the same information will need to be placed in the bootp host's configuration database instead.

When your boot parameters are set properly, just press the reset button on your IOC, or use the \verb|@| command to commence booting.
You will find it VERY convenient to have the console port of the IOC attached to a scrolling window on your workstation.

\section{RTEMS boot procedure}

RTEMS uses the vendor-supplied bootstrap mechanism so the method for booting an IOC depends upon the hardware in use.

\subsection{Booting from a BOOTP/DHCP/TFTP server}

Many boards can use BOOTP/DHCP to read their network configuration and then use TFTP to read the applicaion program.
RTEMS can then use TFTP or NFS to read startup scripts and configuration files.
If you are using TFTP to read the startup scripts and configuration files you must install the EPICS application files on your TFTP server as follows:

\begin{itemize}
\item Copy all \verb|db/xxx| files to \verb|<tftpbase>/epics/<target_hostname\>/db/xxx|.

\item Copy all \verb|dbd/xxx| files to \verb|<tftpbase>/epics/<target_hostname>/dbd/xxx|.

\item Copy the \verb|st.cmd| script  to \verb|<tftpbase>/epics/<target_hostname>/st.cmd|.
\end{itemize}

Use DHCP site-specific option 129 to specify the path to the IOC startup script.

\subsection{Motorola PPCBUG boot parameters}

\index{PPCBUG}
Motorola single-board computers which employ PPCBUG should have their `NIOT' parameters set up like:

\noindent
\verb|Controller LUN =00|\\
\verb|Device LUN     =00|\\
\verb|Node Control Memory Address =FFE10000|\\
\verb|Client IP Address      =|`Dotted-decimal' IP address of IOC\\
\verb|Server IP Address      =|`Dotted-decimal' IP address of TFTP/NFS server\\
\verb|Subnet IP Address Mask =|`Dotted-decimal' IP address of subnet mask (255.255.255.0 for class C subnet)\\
\verb|Broadcast IP Address   =|`Dotted-decimal' IP address of subnet broadcast address\\
\verb|Gateway IP Address     =|`Dotted-decimal' IP address of network gateway (0.0.0.0 if none)\\
\verb|Boot File Name         =|Path to application bootable image (..../bin/RTEMS-mvme2100/test.boot)\\
\verb|Argument File Name     =|Path to application startup script (..../iocBoot/ioctest/st.cmd)\\
\verb|Boot File Load Address         =001F0000| (actual value depends on BSP)\\
\verb|Boot File Execution Address    =001F0000| (actual value depends on BSP)\\
\verb|Boot File Execution Delay      =00000000|\\
\verb|Boot File Length               =00000000|\\
\verb|Boot File Byte Offset          =00000000|\\
\verb|BOOTP/RARP Request Retry       =00      |\\
\verb|TFTP/ARP Request Retry         =00      |\\
\verb|Trace Character Buffer Address =00000000|

\subsection{Motorola MOTLOAD boot parameters}

\index{MOTLOAD}
Motrola single-board computers which employ MOTLOAD should have their network `Global Environment Variable' parameters set up like:

\noindent
\verb|mot-/dev/enet0-cipa=|`Dotted-decimal' IP address of IOC\\
\verb|mot-/dev/enet0-sipa=|`Dotted-decimal' IP address of TFTP/NFS server\\
\verb|mot-/dev/enet0-snma=|`Dotted-decimal' IP address of subnet mask (255.255.255.0 for class C subnet)\\
\verb|mot-/dev/enet0-gipa=|`Dotted-decimal' IP address of network gateway (omit if none)\\
\verb|mot-/dev/enet0-file=|Path to application bootable image (..../bin/RTEMS-mvme5500/test.boot)\\
\verb|rtems-client-name=|IOC name (mot-/dev/enet0-cipa will be used if this parameter is missing)\\
\verb|rtems-dns-server=|'Dotted-decimal' IP address of domain name server (omit if none)\\
\verb|rtems-dns-domainname=|Domain name (if this parameter is omitted the compiled-in value will be used)\\
\verb|epics-script=|Path to application startup script (..../iocBoot/ioctest/st.cmd)

The \verb|mot-script-boot| parameter should be set up like:

\begin{verbatim}
tftpGet -a4000000 -cxxx -sxxx -mxxx -gxxx -d/dev/enet0
        -f..../bin/RTEMS-mvme5500/test.boot
netShut
go -a4000000
\end{verbatim}

where the \verb|-c|, \verb|-s|, \verb|-m| and \verb|-g| values should match the cipa, sipa, snma and gipa values, respectively and the \verb|-f| value should match the file value.

\subsection{RTEMS NFS access}

For IOCs which use NFS for remote file access the EPICS initialization code uses the startup script pathname to determine the parameters for the initial NFS mount.
If the startup script pathname begins with a `\verb|/|' the first component of the pathname is used as both the server path and the local mount point.
If the startup script pathname does not begin with a `\verb|/|' the first component of the pathname is used as the local mount point and the server path is ``\verb|/tftpboot/|'' followed by the first component of the pathname.
This allows the NFS client used for EPICS file access and the TFTP client used for bootstrapping the application to have a similar view of the remote filesystem.

\subsection{RTEMS `Cexp'}

\index{Cexp}The RTEMS `Cexp' add-on package provides the ability to load object modules at application run-time.
If your RTEMS build includes this package you can load RTEMS IOC applications in the same fashion as vxWorks IOC applications.

