\chapter{Database Definition}
\index{Database Definition}

\section{Overview}

This chapter describes \index{database definitions}database definitions. The following definitions are described:

\begin{itemize}
\item Menu
\item Record Type
\item Device
\item Driver
\item Registrar
\item Variable
\item Function
\item Breakpoint Table
\item Record Instance
\end{itemize}

Record Instances are fundamentally different from the other definitions. A file containing record instances should never 
contain any of the other definitions and vice-versa. Thus the following convention is followed:

\begin{description}
\index{Database Definition File}
\item [Database Definition File] A file that contains any type of definition except record instances.

\index{Record Instance File}
\item [Record Instance File] A file that contains only record instance definitions.
\end{description}

This chapter also describes utility programs which operate on these definitions

Any combination of definitions can appear in a single file or in a set of files related to each other via include files.

\section{Summary of Database Syntax}

\index{Database Format -- Summary}
The following summarizes the Database Definition syntax:

\begin{verbatim}
path "path"
addpath "path"
include "filename"
#comment
menu(name) {
    include "filename"
    choice(choice_name, "choice_value")
    ...
}

recordtype(record_type) {
    include "filename"
    field(field_name, field_type) {
        asl(asl_level)
        initial("init_value")
        promptgroup(gui_group)
        prompt("prompt_value")
        special(special_value)
        pp(pp_value)
        interest(interest_level)
        base(base_type)
        size(size_value)
        extra("extra_info")
        menu(name)
    }
    %C_declaration
    ...
}

device(record_type, link_type, dset_name, "choice_string")

driver(drvet_name)

registrar(function_name)

variable(variable_name)

breaktable(name) {
    raw_value eng_value
    ...
}
\end{verbatim}

The Following defines a Record Instance

\begin{verbatim}
record(record_type, record_name) {
include "filename"
field(field_name, "value")
    alias(alias_name)
    info(info_name, "value")
    ...
}
alias(record_name,alias_name)
\end{verbatim}

\section{General Rules for Database Definition}

\subsection{Keywords}

\index{Keywords}
The following are keywords, i.e. they may not be used as values unless they are enclosed in quotes:

\index{path}
\index{addpath}
\index{include}
\index{menu}
\index{choice}
\index{recordtype}
\index{field}
\index{device}
\index{driver}
\index{registrar}
\index{function}
\index{variable}
\index{breaktable}
\index{record}
\index{grecord}
\index{info}
\index{alias}
\begin{verbatim}
path
addpath
include
menu
choice
recordtype
field
device
driver
registrar
function
variable
breaktable
record
grecord
info
alias
\end{verbatim}

\subsection{Unquoted Strings}

\index{Unquoted String}
In the summary section, some values are shown as quoted strings and some unquoted. The actual rule is that any string 
consisting of only the following characters does not have to be quoted unless it contains one of the above keywords:

\begin{verbatim}
a-z A-Z 0-9 _ - : . [ ] < > ;
\end{verbatim}

These are also the legal characters for process variable names. Thus in many cases quotes are not needed.

\subsection{Quoted Strings}

\index{Quoted String}
A quoted string can contain any ascii character except the quote character \verb|"|. The quote character itself can given by using \verb|\| as an escape. For example \verb|"\""| is a quoted string containing the single character \verb|"|.

\subsection{Macro Substitution}

\index{Macro Substitution}
Macro substitutions are permitted inside quoted strings. Macro instances take the form:

\begin{verbatim}
$(name)
\end{verbatim}

or

\begin{verbatim}
${name}
\end{verbatim}

There is no distinction between the use of parentheses or braces for delimiters, although the two must match for a given 
macro instance. The macro name can be made up from other macros, for example:

\begin{verbatim}
$(name_$(sel))
\end{verbatim}

A macro instance can also provide a default value that is used when no macro with the given name is defined. The default 
value can be defined in terms of other macros if desired, but cannot contain any unescaped comma characters. The syntax 
for specifying a default value is as follows:

\begin{verbatim}
$(name=default)
\end{verbatim}

Finally macro instances can also contain definitions of other macros, which can (temporarily) override any existing values 
for those macros but are in scope only for the duration of the expansion of this macro instance. These definitions consist 
of \verb|name=value| sequences separated by commas, for example:

\begin{verbatim}
$(abcd=$(a)$(b)$(c)$(d),a=A,b=B,c=C,d=D)
\end{verbatim}

\subsection{Escape Sequences}

\index{Escape Sequence}
The database routines translate standard C escape sequences inside database field value strings only. The standard C 
escape sequences supported are:

\begin{verbatim}
\a \b \f \n \r \t \v \\ \? \' \" \ooo \xhh
\end{verbatim}

\verb|\ooo| represents an octal number with 1, 2, or 3 digits. \verb|\xhh| represents a hexadecimal number with 1 or 2 digits.

\subsection{Comments}

\index{comment -- Database Definitions}
The comment symbol is ``\#''. Whenever the comment symbol appears, it and all characters through the end of the line are ignored.

\subsection{Define before referencing}

No item can be referenced until it is defined. For example a \verb|recordtype| menu field can not reference a menu unless 
that menu definition has already been defined. Another example is that a record instance can not appear until the 
associated record type has been defined.

\subsection{Multiple Definitions}

\index{Multiple Definitions}
If a menu, recordtype, device, driver, or breakpoint table is defined more than once, then only the first instance is used. 
Record instance definitions however are (normally) cumulative, so multiple instances of the same record may be loaded 
and each time a field value is encountered it replaces the previous value.

\subsection{Filename Extensions}

\index{filename extension conventions}
By convention:

\begin{itemize}
\item Record instances files have the extension ``\verb|.db|'' or ``\verb|.vdb|'' if the file also contains visual layout information

\item Database definition files have the extension ``\verb|.dbd|''

\end{itemize}

\section{\texttt{path addpath} -- Path Definition}

\index{path -- Database Definitions}
\index{addpath -- Database Definitions}
\subsection{Format}

\begin{verbatim}
path "dir:dir...:dir"
addpath "dir:dir...:dir
\end{verbatim}

The path string follows the standard convention for the operating system, i.e. directory names are separated by a colon ``\verb|:|'' on Unix
and a semicolon ``\verb|;|'' on Windows.

The \verb|path| command specifies the current search path for use when loading database and database definition files.
The \verb|addpath| appends directory names to the current path.
The path is used to locate the initial database file and included files.
An empty \verb|dir| at the beginning, middle, or end of a non-empty path string means the current directory.
For example:

\begin{verbatim}
 nnn::mmm    # Current directory is between nnn and mmm
 :nnn        # Current directory is first
 nnn:        # Current directory is last
\end{verbatim}

Utilities which load database files (\verb|dbExpand|, \verb|dbLoadDatabase|, etc.) allow the user to specify an initial path. The 
\verb|path| and \verb|addpath| commands can be used to change or extend the initial path.

The initial path is determined as follows:

\begin{description}
\item If an initial path is specified, it is used. Else:

\item If the environment variable \verb|EPICS_DB_INCLUDE_PATH| is defined, it is used. Else:

\item the default path is ``\verb|.|'', i.e. the current directory.
\end{description}

The path is used unless the filename contains a \verb|/| or \verb|\|.
The first directory containing the specified filename is used.

\section{\texttt{include} -- Include File}

\index{include -- Database Definitions}
\subsection{Format}

\begin{verbatim}
include "filename"
\end{verbatim}

An include statement can appear at any place shown in the summary.
It uses the path as specified above.

\section{\texttt{menu} -- Menu Declaration}

\index{menu -- Database Definitions}
\subsection{Format}

\begin{verbatim}
menu(name) {
    choice(choice_name, "choice_string")
    ...
}
\end{verbatim}

\subsection{Definitions}

\begin{description}
\item [name] Name for menu. This is the unique name identifying the menu.
If duplicate definitions are specified, only the first is used.

\item [choice\_name] The name used in the \verb|enum| generated by \verb|dbToMenuH| or \verb|dbToRecordtypeH|.
This must be a legal C/C++ identifier.

\item [choice\_string] The text string associated with this particular choice.
\end{description}

\subsection{Example}

\begin{verbatim}
menu(menuYesNo) {
    choice(menuYesNoNO, "NO")
    choice(menuYesNoYES, "YES")
}
\end{verbatim}

\section{\texttt{recordtype} -- Record Type Declaration}

\index{record type -- Database Definitions}
\subsection{Format}

\begin{verbatim}
recordtype(record_type) {
    field(field_name, field_type) {
        asl(as_level)
        initial("init_value")
        promptgroup(gui_group)
        prompt("prompt_value")
        special(special_value)
        pp(pp_value)
        interest(interest_level)
        base(base_type)
        size(size_value)
        extra("extra_info")
        menu("name")
    }
    %C_declaration
    ...
}
\end{verbatim}

\subsection{Field Definition Rules}

\index{field definition rules}
\begin{description}

\index{asl -- field definition rules}
\item [asl] Sets the Access Security Level for the field.
Access Security is discussed in chapter \ref{Access Security}.

\index{initial -- field definition rules}
\item [initial] Provides an initial (default) value for the field.

\index{promptgroup -- field definition rules}
\item [promptgroup] The group to which the field belongs, for database configuration tools.

\index{prompt -- field definition rules}
\item [prompt] A prompt string for database configuration tools.
Optional if \verb|promptgroup| is not defined.

\index{special -- field definition rules}
\item [special] If specified, special processing is required for this field at run time.

\index{pp -- field definition rules}
\item [pp] Whether a passive record should be processed when Channel Access writes to this field.

\index{interest -- field definition rules}
\item [interest] Interest level for the field.

\index{base -- field definition rules}
\item [base] For integer fields, the number base to use when converting the field value to a string.

\index{size -- field definition rules}
\item [size] Must be specified for \verb|DBF_STRING| fields.

\index{extra -- field definition rules}
\item [extra] Must be specified for \verb|DBF_NOACCESS| fields.

\index{menu -- field definition rules}
\item [menu] Must be specified for \verb|DBF_MENU| fields. It is the name of the associated menu.
\end{description}

\subsection{Definitions}

\begin{description}
\index{record\_type -- record type definition}
\item [record\_type] The unique name of the record type.
If duplicates are specified, only the first definition is used.

\index{field\_name -- field definition}
\item [field\_name] The field name, which must be a valid C identifier.
When include files are generated, the field name is converted to lower case.
Previous versions of EPICS required the field name be a maximum of four characters, but this restriction no longer applies.

\index{field\_type -- field definition}
\item [field\_type] This must be one of the following values:

\begin{itemize}
\item \verb|DBF_STRING|
\item \verb|DBF_CHAR|, \verb|DBF_UCHAR|
\item \verb|DBF_SHORT|, \verb|DBF_USHORT|
\item \verb|DBF_LONG|, \verb|DBF_ULONG|
\item \verb|DBF_FLOAT|, \verb|DBF_DOUBLE|
\item \verb|DBF_ENUM|, \verb|DBF_MENU|, \verb|DBF_DEVICE|
\item \verb|DBF_INLINK|, \verb|DBF_OUTLINK|, \verb|DBF_FWDLINK|
\item \verb|DBF_NOACCESS|
\end{itemize}

\index{as\_level -- field definition}
\item [as\_level] This must be one of the following values:

\begin{itemize}
\item \verb|ASL0|
\item \verb|ASL1|  (default value)
\end{itemize}

Fields which operators normally change are assigned \verb|ASL0|.
Other fields are assigned \verb|ASL1|.
For example, the \verb|VAL| field of an analog output record is assigned \verb|ASL0| and all other fields \verb|ASL1|.
This is because only the \verb|VAL| field should be modified during normal operations.

\index{init\_value -- field definition}
\item [init\_value] A legal value for data type.

\index{prompt\_value -- field definition}
\item [prompt\_value] A prompt value for database configuration tools.

\index{gui\_group -- field definition}
\item [gui\_group] This must be one of the following:

\begin{itemize}
\item \verb|GUI_COMMON|
\item \verb|GUI_ALARMS|
\item \verb|GUI_BITS1|
\item \verb|GUI_BITS2|
\item \verb|GUI_CALC|
\item \verb|GUI_CLOCK|
\item \verb|GUI_COMPRESS|
\item \verb|GUI_CONVERT|
\item \verb|GUI_DISPLAY|
\item \verb|GUI_HIST|
\item \verb|GUI_INPUTS|
\item \verb|GUI_LINKS|
\item \verb|GUI_MBB|
\item \verb|GUI_MOTOR|
\item \verb|GUI_OUTPUT|
\item \verb|GUI_PID|
\item \verb|GUI_PULSE|
\item \verb|GUI_SELECT|
\item \verb|GUI_SEQ1|
\item \verb|GUI_SEQ2|
\item \verb|GUI_SEQ3|
\item \verb|GUI_SUB|
\item \verb|GUI_TIMER|
\item \verb|GUI_WAVE|
\item \verb|GUI_SCAN|

This information is for use by Database Configuration Tools.
This is defined only for fields that can be given values by database configuration tools.
File \verb|guigroup.h| contains all possible definitions.
This allows database configuration tools to group fields together by functionality, not just order them by name.
This feature has seldom been used, so many record types do not have appropriate values assigned to some fields.

\end{itemize}

\index{special\_value -- field definition}
\item [special\_value] Must be one of the following:

\begin{itemize}
\index{SPC\_MOD}
\item \verb|SPC_MOD| -- Notify record support when modified.
The record support \verb|special| routine will be called whenever the field is modified by the database access routines.

\index{SPC\_NOMOD}
\item \verb|SPC_NOMOD| -- No external modifications allowed.
This value disables external writes to the field, so it can only be set by the record or device support module.

\index{SPC\_DBADDR}
\item \verb|SPC_DBADDR| -- Use this if the record support \verb|cvt_dbaddr| routine should be called by \verb|dbNameToAddr|,
i.e. when code outside record/device support is connecting to the field.

The following values are for database common fields.
They must \emph{not} be used for record specific fields:

\index{SPC\_SCAN}
\item \verb|SPC_SCAN| -- Scan related field.

\index{SPC\_ALARMACK}
\item \verb|SPC_ALARMACK| -- Alarm acknowledgment field.

\index{SPC\_AS}
\item \verb|SPC_AS| -- Access security field.

The following values are deprecated, use \verb|SPC_MOD| instead:

\item An integer value greater than 103.

\index{SPC\_RESET}
\item \verb|SPC_RESET| -- a reset field is being modified.

\index{SPC\_LINCONV}
\item \verb|SPC_LINCONV| -- A linear conversion field is being modified.

\index{SPC\_CALC}
\item \verb|SPC_CALC| -- A calc field is being modified.
\end{itemize}

\index{pp\_value -- field definition}
\item [pp\_value] Should a passive record be processed when Channel Access writes to this field?
The allowed values are:

\begin{itemize}
\item \verb|NO| (default)
\item \verb|YES|
\end{itemize}

\index{interest\_level -- field definition}
\item [interest\_level] An interest level for the \verb|dbpr| command.

\index{base -- field definition}
\item [base] For integer type fields, the default base.
The legal values are:

\begin{itemize}
\item \verb|DECIMAL| (Default)
\item \verb|HEX|
\end{itemize}

\index{size\_value -- field definition}
\item [size\_value] The number of characters for a \verb|DBF_STRING| field.

\index{extra\_info -- field definition}
\item [extra\_info] For \verb|DBF_NOACCESS| fields, this is the C language definition for the field.
The definition must end with the fieldname in lower case.

\item [\%C\_declaration] A percent sign \verb|%| inside the record body introduces a line of code that is to be included in the generated C header file.
\end{description}

\subsection{Example}

The following is the definition of the event record type:

\begin{verbatim}
recordtype(event) {
    include "dbCommon.dbd" 
    field(VAL,DBF_USHORT) {
        prompt("Event Number To Post")
        promptgroup(GUI_INPUTS)
        asl(ASL0)
    }
    field(INP,DBF_INLINK) {
        prompt("Input Specification")
        promptgroup(GUI_INPUTS)
        interest(1)
    }
    field(SIOL,DBF_INLINK) {
        prompt("Sim Input Specifctn")
        promptgroup(GUI_INPUTS)
        interest(1)
    }
    field(SVAL,DBF_USHORT) {
        prompt("Simulation Value")
    }
    field(SIML,DBF_INLINK) {
        prompt("Sim Mode Location")
        promptgroup(GUI_INPUTS)
        interest(1)
    }
    field(SIMM,DBF_MENU) {
        prompt("Simulation Mode")
        interest(1)
        menu(menuYesNo)
    }
    field(SIMS,DBF_MENU) {
        prompt("Sim mode Alarm Svrty")
        promptgroup(GUI_INPUTS)
        interest(2)
        menu(menuAlarmSevr)
    }
}
\end{verbatim}

\section{\texttt{device} -- Device Support Declaration}

\index{device -- Database Definitions}
\subsection{Format}

\begin{verbatim}
    device(record_type, link_type, dset_name, "choice_string")
\end{verbatim}

\subsection{Definitions}

\begin{description}
\index{record\_type -- device definition}
\item [record\_type] Record type.
The combination of \verb|record_type| and \verb|choice_string| must be unique.
If the same combination appears more than once, only the first definition is used.

\index{link\_type -- device definition}
\item [link\_type] Link type. This must be one of the following:

\begin{itemize}
\item \verb|CONSTANT|
\item \verb|PV_LINK|
\item \verb|VME_IO|
\item \verb|CAMAC_IO|
\item \verb|AB_IO|
\item \verb|GPIB_IO|
\item \verb|BITBUS_IO|
\item \verb|INST_IO|
\item \verb|BBGPIB_IO|
\item \verb|RF_IO|
\item \verb|VXI_IO|
\end{itemize}

\index{dset\_name -- device definition}
\item [dset\_name] The name of the device support entry table for this device support.

\index{choice\_string -- device definition}
\item [choice\_string] The \verb|DTYP| choice string for this device support.
A \verb|choice_string| value may be reused for different record types, but must be unique for each specific record type.
\end{description}

\subsection{Examples}

\begin{verbatim}
    device(ai,CONSTANT,devAiSoft,"Soft Channel")
    device(ai,VME_IO,devAiXy566Se,"XYCOM-566 SE Scanned")
\end{verbatim}

\section{\texttt{driver} -- Driver Declaration}

\index{driver -- database definition}
\subsection{Format}

\begin{verbatim}
    driver(drvet_name)
\end{verbatim}

\subsection{Definitions}

\begin{description}
\index{drvet\_name -- driver definition}
\item [drvet\_name] If duplicates are defined, only the first is used.

\end{description}

\subsection{Examples}

\begin{verbatim}
    driver(drvVxi)
    driver(drvXy210)
\end{verbatim}

\section{\texttt{registrar} -- Registrar Declaration}

\index{registrar -- Database Defintions}
\subsection{Format}

\begin{verbatim}
    registrar(function_name)
\end{verbatim}

\subsection{Definitions}

\begin{description}
\index{function\_name -- registrar definition}
\item [function\_name] The name of an C function that accepts no arguments, returns \verb|void| and has been marked in
its source file with an \index{epicsExportRegistrar}\verb|epicsExportRegistrar| declaration, e.g.
\end{description}

\begin{verbatim}
    static void myRegistrar(void);
    epicsExportRegistrar(myRegistrar);
\end{verbatim}

This can be used to register functions for use by subroutine records or that can be invoked from iocsh. The example 
application described in Section \ref{Example IOC Application}, ``Example IOC Application'' on page \pageref{Example IOC Application}
gives an example of how to register functions for subroutine records.

\subsection{Example}

\begin{verbatim}
    registrar(myRegistrar)
\end{verbatim}

\section{\texttt{variable} -- Variable Declaration}

\index{variable -- Database Definitions}
\subsection{Format}

\begin{verbatim}
    variable(variable_name[, type])
\end{verbatim}

\subsection{Definitions}

\begin{description}
\index{variable\_name -- variable definition}
\item [variable\_name] The name of a C variable which has been marked in its source file with an 
\index{epicsExportAddress}\verb|epicsExportAddress| declaration.

\index{type -- variable definition}
\item [type] The C variable's type.
If not present, \verb|int| is assumed.
Currently only \verb|int| and \verb|double| variables are supported.
\end{description}

This registers a diagnostic/configuration variable for device or driver support or a subroutine record subroutine so that
the variable can be read and set with the iocsh \verb|var| command (see Section \ref{Utility Commands} on page \pageref{Utility Commands}).
The example application described in Section \ref{Example IOC Application} on page \pageref{Example IOC Application}
provides an example of how to register a debug variable for a subroutine record.

\subsection{Example}

In an application C source file:

\begin{verbatim}
    #include <epicsExport.h>

    static double myParameter;
    epicsExportAddress(double, myParameter);
\end{verbatim}

In an application database definition file:

\begin{verbatim}
    variable(myParameter, double)
\end{verbatim}

\section{\texttt{function} -- Function Declaration}

\index{function -- Database Definitions}
\subsection{Format}

\begin{verbatim}
function(function_name)
\end{verbatim}

\subsection{Definitions}

\begin{description}
\index{function\_name -- function definition}
\item [function\_name] The name of a C function which has been exported from its source file with an
\index{epicsRegisterFunction}\verb|epicsRegisterFunction| declaration.
\end{description}

This registers a function so that it can be found in the function registry for use by record types such as sub or aSub which 
refer to the function by name. The example application described in Section \ref{Example IOC Application} on page \pageref{Example IOC Application}
provides an example of how to register functions for a subroutine record.

\subsection{Example}

In an application C source file:

\begin{verbatim}
    #include <epicsExport.h>
    #include <registryFunction.h>

    static long myFunction(void *argp) {
        /* my code ... */
    }
    epicsRegisterFunction(myFunction);
\end{verbatim}

In an application database definition file:

\begin{verbatim}
    function(myFunction)
\end{verbatim}

\section{\texttt{breaktable} -- Breakpoint Table}

\index{breakpoint table -- Database Definitions}
\index{breaktable}
\subsection{Format}

\begin{verbatim}
breaktable(name) {
    raw_value eng_value
    ...
}
\end{verbatim}

\subsection{Definitions}

\begin{description}
\index{name -- breakpoint table}
\item [name] Name, which must be alpha-numeric, of the breakpoint table.
If duplicates are specified the first is used.

\index{raw\_value -- breakpoint table}
\item [raw\_value] The raw value, i.e. the actual ADC value associated with the beginning of the interval.

\index{eng\_value -- breakpoint table}
\item [eng\_value] The engineering value associated with the beginning of the interval.
\end{description}

\subsection{Example}

\begin{verbatim}
breaktable(typeJdegC) {
    0.000000 0.000000
    365.023224 67.000000
    1000.046448 178.000000
    3007.255859 524.000000
    3543.383789 613.000000
    4042.988281 692.000000
    4101.488281 701.000000
}
\end{verbatim}

\section{\texttt{record} -- Record Instance}

\index{record instance -- Database Definitions}
\index{record}
\subsection{Format}

\begin{verbatim}
record(record_type, record_name) {
    alias(alias_name)
    field(field_name, "field_value")
    info(info_name, "info_value")
    ...
}
alias(record_name, alias_name)
\end{verbatim}

\subsection{Definitions}

\begin{description}
\index{record\_type -- record instance definition}
\item [record\_type] The record type.

\index{record\_name -- record instance definition}
\item [record\_name] The record name.
This must be composed of the following characters:

\begin{verbatim}
    a-z A-Z 0-9 _ - + : [ ] < > ;
\end{verbatim}

NOTE: If macro substitutions are used the name must be quoted.

If duplicate definitions are given for the same record, then the last value given for each field is the value assigned 
to the field.

\index{alias\_name -- record instance definition}
\item [alias\_name] An alternate name for the record, following the same rules as the record name.

\index{field\_name -- record instance definition}
\item [field\_name] A field name.

\index{field value -- record instance definition}
\item [field\_value] A value for the named field, depending on the particular field type.
Inside double quotes the field value string may contain escaped C89 characters such as 
\verb|\"|, \verb|\t|, \verb|\n|, \verb|\064| and \verb|\x7e|, and these will be translated appropriately when loading the database.
Permitted values are as follows:

\begin{itemize}
\item \verb|DBF_STRING| \\
Any ASCII string. If it exceeds the field length, it will be truncated.

\item \verb|DBF_CHAR|, \verb|DBF_UCHAR|, \verb|DBF_SHORT|, \verb|DBF_USHORT|, \verb|DBF_LONG|, \verb|DBF_ULONG| \\
A string that represents a valid integer. The standard C conventions are applied, i.e. a leading 0 means the 
value is given in octal and a leading 0x means that value is given in hex.

\item \verb|DBF_FLOAT|, \verb|DBF_DOUBLE| \\
The string must represent a valid floating point number.

\item \verb|DBF_MENU| \\
The string must be one of the valid choices for the associated menu.

\item \verb|DBF_DEVICE| \\
The string must be one of the valid device choice strings.

\item \verb|DBF_INLINK|, \verb|DBF_OUTLINK|, \verb|DBF_FWDLINK| \\
NOTES:

\begin{itemize}
\item If the field name is \verb|INP| or \verb|OUT| then this field is associated with \verb|DTYP|, and the permitted values
are determined by the link type of the device support selected by the current \verb|DTYP| choice string.
Other \verb|DBF_INLINK| and \verb|DBF_OUTLINK| fields must be either \verb|CONSTANT| or \verb|PV_LINK|s.

\item A device support that specifies a link type of \verb|CONSTANT| can be given either a constant or a \verb|PV_LINK|.
\end{itemize}

The allowed values for the field depend on the device support's link type as follows:

\begin{itemize}
\item \verb|CONSTANT| \\
\index{CONSTANT -- link field value}
A numeric literal, valid for the field type it is to be read into.

\item \verb|PV_LINK| \\
\index{PV\_LINK -- link field value}
A value of the form:

\begin{verbatim}
    record.field process maximize
\end{verbatim}

\verb|record| is the name of a record that exists in this or another IOC.

The \verb|.field|, \verb|process|, and \verb|maximize| parts are all optional.

The default value for \verb|.field| is \verb|.VAL|.

\verb|process| can have one of the following values:

\begin{itemize}
\item \verb|NPP| -- No Process Passive (Default)
\item \verb|PP| -- Process Passive
\item \verb|CA| -- Force link to be a channel access link
\item \verb|CP| -- CA and process on monitor
\item \verb|CPP| -- CA and process on monitor if record is passive

NOTES:

\verb|CP| and \verb|CPP| are valid only for \verb|DBF_INLINK| fields.

\verb|DBF_FWDLINK| fields can use \verb|PP| or \verb|CA|.
If a \verb|DBF_FWDLINK| is a channel access link it must reference the target record's \verb|PROC| field.
\end{itemize}

\verb|maximize| can have one of the following values:

\begin{itemize}
\item \verb|NMS| -- No Maximize Severity (Default)
\item \verb|MS| -- Maximize Severity
\item \verb|MSS| -- Maximize Severity and Status
\item \verb|MSI| -- Maximize Severity if Invalid
\end{itemize}

\index{VME\_IO -- link field value}
\item \verb|VME_IO| \\
\verb|#Ccard Ssignal @parm|

\verb|card| -- the card number of associated hardware module \\
\verb|signal| -- signal on card \\
\verb|parm| -- An arbitrary character string of up to 31 characters. This field is optional and is device specific.

\item \verb|CAMAC_IO| \\
\index{CAMAC\_IO -- link field value}
\verb|#Bbranch Ccrate Nstation Asubaddress Ffunction @parm|

\verb|branch|, \verb|crate|, \verb|station|, \verb|subaddress|, and \verb|function| should be obvious to \verb|camac| users.
\verb|subaddress| and \verb|function| are optional (0 if not given).
\verb|parm| is also optional and is device specific (25 characters max).

\item \verb|AB_IO| \\
\index{AB\_IO -- link field value}
\verb|#Llink Aadapter Ccard Ssignal @parm|

\verb|link| -- Scanner, i.e. vme scanner number \\
\verb|adapter| -- Adapter. Allen Bradley also calls this rack \\
\verb|card| -- Card within Allen Bradley Chassis \\
\verb|signal| -- signal on card \\
\verb|parm| -- optional device-specific character string (27 char max)

\item \verb|GPIB_IO| \\
\index{GPIB\_IO -- link field value}
\verb|#Llink Aaddr @parm|

\verb|link| -- gpib link, i.e. interface \\
\verb|addr| -- GPIB address \\
\verb|parm| -- device-specific character string (31 char max)

\item \verb|BITBUS_IO| \\
\index{BITBUS\_IO -- link field value}
\verb|#Llink Nnode Pport Ssignal @parm|

\verb|link| -- link, i.e.  vme bitbus interface \\
\verb|node| -- bitbus node \\
\verb|port| -- port on the node \\
\verb|signal| -- signal on port \\
\verb|parm| -- device specific-character string (31 char max)

\item \verb|INST_IO|
\index{INST\_IO -- link field value}
\verb|@parm|

\verb|parm| -- Device dependent character string

\item \verb|BBGPIB_IO| \\
\index{BBGPIB\_IO -- link field value}
\verb|#Llink Bbbaddr Ggpibaddr @parm|

\verb|link| -- link, i.e. vme bitbus interface \\
\verb|bbadddr| -- bitbus address \\
\verb|gpibaddr| -- gpib address \\
\verb|parm| -- optional device-specific character string (31 char max)

\item \verb|RF_IO| \\
\index{RF\_IO -- link field value}
\verb|#Rcryo Mmicro Ddataset Eelement|

\item \verb|VXI_IO| \\
\index{VXI\_IO -- link field value}
\verb|#Vframe Cslot Ssignal @parm| (Dynamic addressing) \\
     or \\
\verb|#Vla Signal @parm|  (Static Addressing)

\verb|frame| -- VXI frame number \\
\verb|slot| -- Slot within VXI frame \\
\verb|la| -- Logical Address \\
\verb|signal| -- Signal Number \\
\verb|parm| -- device specific character string(25 char max)
\end{itemize}
\end{itemize}

\index{info\_name -- record instance definition}
\item [info\_name] The name of an Information Item related to this record.
See section \ref{Record Information Item} below for more on Information Items.

\index{info\_value -- record instance definition}
\item [info\_value] Any ASCII string.
IOC applications using this information item may place additional restrictions on the contents of the string.

\end{description}

\subsection{Examples}

\begin{verbatim}
record(ai,STS_AbAiMaS0) {
    field(SCAN,".1 second")
    field(DTYP,"AB-1771IFE-4to20MA")
    field(INP,"#L0 A2 C0 S0 F0 @")
    field(PREC,"4")
    field(LINR,"LINEAR")
    field(EGUF,"20")
    field(EGUL,"4")
    field(EGU,"MilliAmps")
    field(HOPR,"20")
    field(LOPR,"4")
}
record(ao,STS_AbAoMaC1S0) {
    field(DTYP,"AB-1771OFE")
    field(OUT,"#L0 A2 C1 S0 F0 @")
    field(LINR,"LINEAR")
    field(EGUF,"20")
    field(EGUL,"4")
    field(EGU,"MilliAmp")
    field(DRVH,"20")
    field(DRVL,"4")
    field(HOPR,"20")
    field(LOPR,"4")
    info(autosaveFields,"VAL")
}
record(bi,STS_AbDiA0C0S0) {
    field(SCAN,"I/O Intr")
    field(DTYP,"AB-Binary Input")
    field(INP,"#L0 A0 C0 S0 F0 @")
    field(ZNAM,"Off")
    field(ONAM,"On")
}
\end{verbatim}

\section{Record Information Item}
\label{Record Information Item}

\index{Information item}
Information items provide a way to attach named string values to individual record instances that are loaded at the same 
time as the record definition. They can be attached to any record without having to modify the record type, and can be 
retrieved by programs running on the IOC (they are not visible via Channel Access at all). Each item attached to a single 
record must have a unique name by which it is addressed, and database access provides routines to allow a record's info 
items to be scanned, searched for, retrieved and set. At runtime a \verb|void*| \index{Infomation item pointer}pointer can also be associated with each item, 
although only the string value can be initialized from the record definition when the database is loaded.

\section{Record Attributes}

\index{record attribute}
Each record type can have any number of record attributes.
Each attribute is a \index{Psuedo field}psuedo field that can be accessed via database and channel access.
Each attribute has a name that acts like a field name but returns the same value for all instances of the record type.
Two attributes are generated automatically for each record type: \verb|RTYP| and \verb|VERS|.
The value for \verb|RTYP| is the record type name.
The default value for \verb|VERS| is ``none specified'', which can be changed by record support.
Record support can call the following routine to create new attributes or change existing attributes:

\index{dbPutAttribute}
\begin{verbatim}
    long dbPutAttribute(char *recordTypename,
       char *name, char*value)
\end{verbatim}

The arguments are:

\begin{description}
\item \verb|recordTypename| -- The name of recordtype.
\item \verb|name| -- The attribute name, i.e. the psuedo field name.
\item \verb|value| -- The value assigned to the attribute.
\end{description}

\section{Breakpoint Tables -- Discussion}

\index{Breakpoint Tables}
\index{menuConvert}
\index{LINR}
The menu \verb|menuConvert| is used for field \verb|LINR| of the \verb|ai| and \verb|ao| records.
These records allow raw data to be converted to/from engineering units via one of the following:

\begin{enumerate}
\item No Conversion.
\item \index{Slope Conversion}Slope Conversion.
\item \index{Linear Conversion}Linear Conversion.
\item Breakpoint table.
\end{enumerate}

Other record types can also use this feature. The first choice specifies no conversion; the second and third are both linear 
conversions, the difference being that for Slope conversion the user specifies the conversion slope and offset directly, 
whereas for Linear conversions these are calculated by the device support from the requsted Engineering Units range and 
the device support's knowledge of the hardware conversion range. The remaining choices are assumed to be the names of 
breakpoint tables. If a breakpoint table is chosen, the record support modules calls \verb|cvtRawToEngBpt| or 
\verb|cvtEngToRawBpt|. You can look at the \verb|ai| and \verb|ao| record support modules for details.

If a user wants to add additional breakpoint tables, then the following should be done:

\begin{itemize}
\item Copy the \verb|menuConvert.dbd| file from EPICS \verb|base/src/bpt|
\item Add definitions for new breakpoint tables to the end
\item Make sure modified \verb|menuConvert.dbd| is loaded  into the IOC instead of EPICS version.
\end{itemize}

It is only necessary to load a breakpoint file if a record instance actually chooses it. It should also be mentioned that the 
Allen Bradley IXE device support misuses the \verb|LINR| field. If you use this module, it is very important that you do not 
change any of the EPICS supplied definitions in \verb|menuConvert.dbd|. Just add your definitions at the end.

If a breakpoint table is chosen, then the corresponding breakpoint file must be loaded into the IOC before \verb|iocInit| is 
called.

Normally, it is desirable to directly create the breakpoint tables. However, sometimes it is desirable to create a breakpoint 
table from a table of raw values representing equally spaced engineering units. A good example is the Thermocouple 
tables in the OMEGA Engineering, INC Temperature Measurement Handbook. A tool \index{makeBpt}\verb|makeBpt| is provided to convert 
such data to a breakpoint table.

The format for generating a breakpoint table from a data table of raw values corresponding to equally spaced engineering 
values is:

\begin{verbatim}
    !comment line
    <header line>
    <data table>
\end{verbatim}

The header line contains the following information:

\begin{description}
\item [Name] An alphanumeric ascii string specifying the breakpoint table name
\item [Low Value Eng] Engineering Units Value for first breakpoint table entry
\item [Low Value Raw] Raw value for first breakpoint table entry
\item [High Value Eng] Engineering Units: Highest Value desired
\item [High Value Raw] Raw Value for High Value Eng
\item [Error] Allowed error (Engineering Units)
\item [First Table] Engineering units corresponding to first data table entry
\item [Last Table] Engineering units corresponding to last data table entry
\item [Delta Table] Change in engineering units per data table entry
\end{description}

 An example definition is:

\begin{verbatim}
    "TypeKdegF" 32 0 1832 4095 1.0 -454 2500 1
    <data table>
\end{verbatim}

The breakpoint table can be generated by executing

\begin{verbatim}
    makeBpt bptXXX.data
\end{verbatim}

The input file must have the extension of data. The output filename is the same as the input filename with the extension of \verb|.dbd|.

Another way to create the breakpoint table is to include the following definition in a \verb|Makefile|:

\begin{verbatim}
BPTS += bptXXX.dbd
\end{verbatim}

NOTE: This requires the naming convention that all data tables are of the form \verb|bpt<name>.data| and a breakpoint table \verb|bpt<name>.dbd|.

\section{Menu and Record Type Include File Generation.}

\index{Include File Generation}
\subsection{Introduction}

\index{dbToMenuH}
\index{dbToRecordtypeH}
Given a file containing menus, \verb|dbToMenuH| generates an include file that can be used by any code which uses the 
associated menus. Given a file containing any combination of menu definitions and record type definitions, 
\verb|dbToRecordtypeH| generates an include file that can be used by any code which uses the menus and record type.

EPICS base uses the following conventions for managing menu and recordtype definitions. Users generating local record 
types are encouraged to do likewise.

\begin{itemize}
\item Each menu that is either for fields in database common (for example \verb|menuScan|) or is of global use (for example 
\verb|menuYesNo|) is defined in a separate file.
The name of the file is the same as the menu name with an extension of \verb|.dbd|.
The name of the generated include file is the menu name with an extension of \verb|.h|.
Thus \verb|menuScan| is defined in a file \verb|menuScan.dbd| and the generated include file is named \verb|menuScan.h|

\item Each record type definition is defined in a separate file.
In addition, this file contains any menu definitions that are used only by that record type.
The name of the file is the same as the recordtype name followed by \verb|Record.dbd|.
The name of the generated include file is the same name with an extension of \verb|.h|.
Thus \verb|aoRecord| is defined in a file \verb|aoRecord.dbd| and the generated include file is named \verb|aoRecord.h|.
Since \verb|aoRecord| has a private menu called \verb|aoOIF|, the \verb|dbd| file and the generated include file have definitions for this menu.
Thus for each record type, there are two source files (\verb|xxxRecord.dbd| and \verb|xxxRecord.c|) and one generated file (\verb|xxxRecord.h|).
\end{itemize}

Before continuing, it should be mentioned that developers don't normally execute \verb|dbToMenuH| or \verb|dbToRecordtypeH| themselves.
If the proper naming conventions are used, it is only necessary to add definitions to the appropriate \verb|Makefile|.
Consult the chapter on the EPICS Build Facility for details.

\subsection{dbToMenuH}

\index{dbToMenuH}
This tool is executed as follows:

\begin{verbatim}
dbToMenuH -Idir -Smacsub menuXXX.dbd
\end{verbatim}

It generates a file which has the same name as the input file but with an extension of \verb|.h|.
Multiple \verb|-I| options can be specified for an include path and multiple \verb|-S| options for macro substitution.

For example \verb|menuPriority.dbd|, which contains the definitions for processing priority contains:

\begin{verbatim}
menu(menuPriority) {
    choice(menuPriorityLOW,"LOW")
    choice(menuPriorityMEDIUM,"MEDIUM")
    choice(menuPriorityHIGH,"HIGH")
}
\end{verbatim}

The include file, \verb|menuPriority.h|, generated by \verb|dbToMenuH| contains:

\begin{verbatim}
#ifndef INCmenuPriorityH
#define INCmenuPriorityH
typedef enum {
    menuPriorityLOW,
    menuPriorityMEDIUM,
    menuPriorityHIGH,
}menuPriority;
#endif /*INCmenuPriorityH*/

\end{verbatim}

Any code that needs to use the priority menu values should use these definitions.

\subsection{dbToRecordtypeH}

\index{dbToRecordtypeH}
This tool is executed as follows:

\begin{verbatim}
dbTorecordtypeH -Idir -Smacsub xxxRecord.dbd
\end{verbatim}

It generates a file which has the same name as the input file but with an extension of \verb|.h|.
Multiple \verb|-I| options can be specified for an include path and multiple \verb|-S| options for macro substitution.

For example \verb|aoRecord.dbd|, which contains the definitions for the analog output record contains:

\begin{verbatim}
menu(aoOIF) {
    choice(aoOIF_Full,"Full")
    choice(aoOIF_Incremental,"Incremental")
}
recordtype(ao) {
    include "dbCommon.dbd"
    field(VAL,DBF_DOUBLE) {
    prompt("Desired Output")
        asl(ASL0)
        pp(TRUE)
    }
    field(OVAL,DBF_DOUBLE) {
        prompt("Output Value")
    }
    ... (Many more field definitions
    }
}
\end{verbatim}

The include file, \verb|aoRecord.h|, generated by \verb|dbToRecordtypeH| contains:

\begin{verbatim}
#include "ellLib.h"
#include "epicsMutex.h"
#include "link.h"
#include "epicsTime.h"
#include "epicsTypes.h"

#ifndef INCaoOIFH
#define INCaoOIFH
typedef enum {
        aoOIF_Full,
        aoOIF_Incremental,
}aoOIF;
#endif /*INCaoOIFH*/
#ifndef INCaoH
#define INCaoH
typedef struct aoRecord {
        char            name[29]; /*Record Name*/
        ... Remaining fields in database common
        double          val;    /*Desired Output*/
        double          oval;   /*Output Value*/
        ... remaining record specific fields
} aoRecord;
#define aoRecordNAME    0
... defines for remaining fields in database common
#define aoRecordVAL     42
#define aoRecordOVAL    43
... defines for remaining record specific fields
#ifdef GEN_SIZE_OFFSET
int aoRecordSizeOffset(dbRecordType *pdbRecordType)
{
    aoRecord *prec = 0;
  pdbRecordType->papFldDes[0]->size=sizeof(prec->name);
  pdbRecordType->papFldDes[0]->offset=
(short)((char *)&prec->name -- (char *)prec);
  ... code to compute size&offset for other fields in dbCommon
  pdbRecordType->papFldDes[42]->size=sizeof(prec->val);
  pdbRecordType->papFldDes[42]->offset=
(short)((char *)&prec->val -- (char *)prec);
  pdbRecordType->papFldDes[43]->size=sizeof(prec->oval);
  pdbRecordType->papFldDes[43]->offset=
(short)((char *)&prec->oval -- (char *)prec);
  ... code to compute size&offset for remaining fields
  pdbRecordType->rec_size = sizeof(*prec);
  return(0);
}
#endif /*GEN_SIZE_OFFSET*/

\end{verbatim}

The analog output record support module and all associated device support modules should use this include file. No other 
code should use it. Let's discuss the various parts of the file.:

\begin{itemize}
\item The \verb|enum| generated from the menu definition should be used to reference the value of the field associated with the 
menu.

\item The \verb|typedef| and \verb|structure| defining the record are used by record support and device support to access fields 
in an analog output record.

\item A \verb|#define| is present for each field within the record. This is useful for the record support routines that are passed 
a pointer to a \verb|DBADDR| structure. They can have code like the following:

\end{itemize}

\begin{verbatim}
switch (dbGetFieldIndex(pdbAddr)) {
    case aoRecordVAL :
        ...
        break;
    case aoRecordXXX:
        ...
        break;
    default:
        ...
}
\end{verbatim}

The C source routine \verb|aoRecordSizeOffset| is automatically called when a record type file is loaded into an IOC. 
Thus user code does not have to be aware of this routine except for the following convention: The associate record 
support module MUST include the statements:

\begin{verbatim}
#define GEN_SIZE_OFFSET
#include "xxxRecord.h"
#undef GEN_SIZE_OFFSET
\end{verbatim}

This convention ensures that the routine is defined exactly once.

\section{dbExpand}

\index{dbExpand}
\begin{verbatim}
dbExpand -Idir -Smacsub -ooutfile file1 file2 ...
\end{verbatim}

Multiple \verb|-I| options can be specified for an include path, and multiple \verb|-S| options for macro substitution. If no output 
filename is specified with \verb|-ooutfile| then the output will go to stdout. Note that the environment variable 
\verb|EPICS_DB_INCLUDE_PATH| can also be used in place of the \verb|-I| options.

NOTE: This is supported only on the host.

This command reads all the input files and then writes a file containing the definitions for all information described by the 
input files. The output content differs from the input in that comment lines do not appear and all include files are 
expanded.

This routine is extremely useful if an IOC is not using NFS for the \verb|dbLoadDatabase| commands. It takes more than 2 
minutes to load the \verb|base/rec/base.dbd| file into an IOC if NFS is not used. If \verb|dbExpand| creates a local \verb|base.dbd| 
file, it takes about 7 seconds to load (25 MHZ 68040 IOC).

\section{dbLoadDatabase}

\index{dbLoadDatabase}
\begin{verbatim}
dbLoadDatabase(char *dbdfile, char *path, char *substitutions)
\end{verbatim}

NOTES: 

\begin{itemize}
\item IOC Only

\item Using a path on a vxWorks ioc does not work very well.

\item Both path and substitutions can be null.

\item \verb|dbdfile| may contain environment variable macros of the form \verb|${MOTOR}| which will be expanded before the 
file is opened.

\end{itemize}

This command loads a database file containing any of the definitions given in the summary at the beginning of this 
chapter. Note that normally \verb|dbLoadDatabase| is only used to load a Database Definition (\verb|.dbd|) file, but it is currently 
possible to use it for loading Record Instance (\verb|.db|) files as well.

As each line of dbdfile is read, the substitutions specified in \verb|substitutions| are performed. Substitutions are specified as follows:

\begin{verbatim}
"var1=sub1,var2=sub3,..."
\end{verbatim}

Variables are specified in the dbfile as \verb|$(var)|. If the substitution string

\begin{verbatim}
"a=1,b=2,c=\"this is a test\""
\end{verbatim}

were used, any variables \verb|$(a)|, \verb|$(b)|, \verb|$(c)| would be substituted with the appropriate data.

\section{dbLoadRecords}

\index{dbLoadRecords}
\begin{verbatim}
dbLoadRecords(char* dbfile, char* substitutions)
\end{verbatim}

NOTES:

\begin{itemize}
\item IOC Only.

\item The file indicated by \verb|dbfile| should contain only record instances, record aliases and/or breakpoint tables.

\item The \verb|dbfile| string may itself contain environment variable macros of the form \verb|${MOTOR}| which will be 
expanded before the file is opened.

\end{itemize}

\subsection{Example}

For example, let the file \verb|test.db| contain:

\begin{verbatim}
record(ai, "$(pre)testrec1")
record(ai, "$(pre)testrec2")
record(stringout, "$(pre)testrec3") {
    field(VAL, "$(STR)")
    field(SCAN, "$(SCAN)")
}
\end{verbatim}

Then issuing the command:

\begin{verbatim}
dbLoadRecords("test.db", 0, "pre=TEST,STR=test,SCAN=Passive")
\end{verbatim}

gives the same results as loading:

\begin{verbatim}
record(ai, "TESTtestrec1")
record(ai, "TESTtestrec2")
record(stringout, "TESTtestrec3") {
    field(VAL, "test")
    field(SCAN, "Passive")
}
\end{verbatim}

\section{dbLoadTemplate}

\index{dbLoadTemplate}
\begin{verbatim}
dbLoadTemplate(char* template_def)
\end{verbatim}

NOTES:

\begin{itemize}
\item IOC Only.

\item MSI can be used to expand templates on the host instead of using this.

\end{itemize}

\verb|dbLoadTemplate| reads a template definition file. This file contains rules about loading database instance files, which
contain \verb|$(xxx)| macros, and performing substitutions.

\verb|template_def| contains the rules for performing substitutions on the instance files. For convenience two formats are
provided. The format is either:

\begin{verbatim}
file name.template {
    { var1=sub1_for_set1, var2=sub2_for_set1, var3=sub3_for_set1, ... }
    { var1=sub1_for_set2, var2=sub2_for_set2, var3=sub3_for_set2, ... }
    { var1=sub1_for_set3, var2=sub2_for_set3, var3=sub3_for_set3, ... }
}
\end{verbatim}

or:

\begin{verbatim}
file name.template {
pattern { var1, var2, var3, ... }
    { sub1_for_set1, sub2_for_set1, sub3_for_set1, ... }
    { sub1_for_set2, sub2_for_set2, sub3_for_set2, ... }
    { sub1_for_set3, sub2_for_set3, sub3_for_set3, ... }
}
\end{verbatim}

The first line (\verb|file name.template|) specifies the record instance input file. The file name may appear inside double
quotation marks; these are required if the name contains any characters that are not in the following set, or if it contains
environment variable macros of the form \verb|${ENV_VAR_NAME}| which are to be expanded before the file is opened:

\begin{verbatim}
a-z A-Z 0-9 _ + - . / \ : ; [ ] < >
\end{verbatim}

Each set of definitions enclosed in \verb|{}| is variable substitution for the input file. The input file has each set applied to it to
produce one composite file with all the completed substitutions in it. Version 1 should be obvious. In version 2, the
variables are listed in the \verb|pattern{}| line, which must precede the braced substitution lines. The braced substitution
lines contains sets which match up with the \verb|pattern{}| line.

\subsection{Example}

Two simple template file examples are shown below. The examples specify the same substitutions to perform: 
\verb|this=sub1| and \verb|that=sub2| for a first set, and \verb|this=sub3| and \verb|that=sub4| for a second set. 

\begin{verbatim}
file test.template {
    { this=sub1,that=sub2 }
    { this=sub3,that=sub4 }
}

file test.template {
    pattern{this,that}
    {sub1,sub2}
    {sub3,sub4 }
}
\end{verbatim}

Assume that the file \verb|test.template| contains:

\begin{verbatim}
record(ai,"$(this)record") {
    field(DESC,"this = $(this)")
}
record(ai,"$(that)record") {
    field(DESC,"this = $(that)")
}
\end{verbatim}

Using \verb|dbLoadTemplate| with either input is the same as defining the records:

\begin{verbatim}
record(ai,"sub1record") {
    field(DESC,"this = sub1")
}
record(ai,"sub2record") {
    field(DESC,"this = sub2")
}

record(ai,"sub3record") {
    field(DESC,"this = sub3")
}
record(ai,"sub4record") {
    field(DESC,"this = sub4")
}
\end{verbatim}

\section{dbReadTest}

\index{dbReadTest}
\begin{verbatim}
dbReadTest -Idir -Smacsub file.dbd ... file.db ...
\end{verbatim}

This utility can be used to check for correct syntax in database definition and database instance files. It just reads all the 
specified files

Multiple \verb|-I,| and \verb|-S |options can be specified. An arbitrary number of database definition and database instance files can 
be specified.
